[
  {
    "objectID": "03.xcp.html",
    "href": "03.xcp.html",
    "title": "XCP",
    "section": "",
    "text": "# #|export\n# from candycan.data_link_socketcan import done, send_msg\n\n\n\nget_argparser\n\n get_argparser ()\n\n*Summary Get argument parser for command line arguments\nReturns: argparse.ArgumentParser: description*\n\nparser = get_argparser()\nargs = parser.parse_args(\n    args=[\n        '--protocol', 'xcp',\n        '--download',\n        '--a2l', repo.working_dir+'/res/VBU_AI.json',\n        '--node-path', r'/PROJECT/MODULE[]',\n        '--leaves', r'TQD_trqTrqSetNormal_MAP_v, VBU_L045A_CWP_05_09T_AImode_CM_single, Lookup2D_FLOAT32_IEEE, Lookup2D_X_FLOAT32_IEEE, Scalar_FLOAT32_IEEE, TQD_vVehSpd, TQD_vSgndSpd_MAP_y, TQD_pctAccPedPosFlt, TQD_pctAccPdl_MAP_x',\n        '--channel', '3',\n        '--download_id', '630',\n        '--upload_id', '631',\n        '--input', repo.working_dir+'/res/download.json',\n        '--output', repo.working_dir+'/res/output.json',\n    ]\n)\n\n\nxcp_calib_from_xcpjson = Get_XCPCalib_From_XCPJSon(args.input)\n\nxcp_data = Generate_Init_XCPData_From_A2L(\n    a2l=args.a2l, keys=args.leaves, node_path=args.node_path\n)\n\n#  address from xcp data file should align with the address from xcp calib file\ntest_eq(xcp_data.address, xcp_calib_from_xcpjson.data[0].address)\n\n# validate the model\ntry:\n    XCPData.model_validate(xcp_data)\nexcept ValidationError as exc:\n    print(exc)\n\n\n# type(args.channel), type(args.download_id), args.upload_id, args.download, args.diff_flashing\n\n\nxcp_data.value = xcp_calib_from_xcpjson.data[0].value\npprint(xcp_data)\n\nxcp_calib = XCPCalib(\n    config=XCPConfig(\n        channel=args.channel, download=str(args.download_id), upload=str(args.upload_id)\n    ),\n    data=[xcp_data],\n)\npprint(xcp_calib)\n\n\nnpa =  xcp_calib.data[0].value_array_view\nnpa\n\n\n# buffer = [i.hex() for x in npa for i in x]\n# # buffer[::-1]\n# len(buffer)\n# buffer\n\n\n# buffer = npa.tobytes()\n\n# pprint(buffer), len(buffer)\n# xcp_calib.data[0].value, len(xcp_calib.data[0].value)\n\n\naddr = bytes('7000aa2a', 'utf-8')\na = 0x7000aa2a\na\n\n\nnpb = npa[::-1]\n# npb\nbuffer = [struct.pack(\"&lt;f\", x) for x in np.nditer(npa)]\n# buffer\nlen(buffer)\n\n\n\n\nnpa_to_packed_buffer\n\n npa_to_packed_buffer (a:numpy.ndarray)\n\n*convert a numpy array to a packed string buffer for flashing TODO: implementation as numpy ufunc\nArgs: a (np.ndarray): input numpy array for flashing\nReturns: str: packed string buffer for flashing*\n\n# buffer = [struct.pack(\"&lt;f\", x).hex() for x in np.nditer(npa)]\n# buffer[::-1]\n# len(buffer)\n# buffer\n# data = ''.join(buffer)\ndata = npa_to_packed_buffer(npa)\ntest_eq(data, xcp_calib.data[0].value)\n# data\n\n\n# npa.astype(np.float32).tobytes().hex()\nbuffer = npa.astype(np.float32).tobytes().hex()  ## == npa_to_packed_buffer(npa)\nbuffer, len(buffer)\ntest_eq(buffer, xcp_calib.data[0].value)\n\n\n\n\nflash_xcp\n\n flash_xcp (xcp_calib:candycan.a2l.XCPCalib,\n            data:pandas.core.frame.DataFrame, diff_flashing:bool=False,\n            download:bool=True)\n\n*Summary Flash XCP data to target\nArgs: xcp_calib (XCPCalib): XCP calibration as template, contains all the meta information except for data xcp_data (pd.DataFrame): input XCP data to be flashed, replace the value in xcp_calib diff_flashing (bool): Use differential flashing download (bool): Download or upload*\n\npkt = IP()\npkt.canvas_dump()\n\n\nIP()\na = IP(dst=\"10.10.10.28\")\na.dst\na.ttl\nls(IP)\n\n\na = IP(ttl=10)\na.src\na.dst=\"192.168.1.1\"\na\nEther()/IP()/TCP()\nraw(IP())\n# IP(_)\n# a = Ether()/IP(dst=\"www.slashdot.org\")/TCP()/\"GET /index.html HTTP \\n\\n\"\na = Ether()/IP(dst=\"www.baidu.com\")/TCP()/\"GET /index.html HTTP \\n\\n\"\nhexdump(a)\nb=raw(a)\nb\nc = Ether(b)\nc\nc.hide_defaults()\nc\n\n\nos.getcwd()\na = rdpcap('../res/pcaps/ipfix.pcap')\na\n# a[0].pdfdump(layer_shift=1)\na[1].psdump(\"/tmp/ipfix.eps\", layer_shift=1)\n\n\na=IP(dst=\"www.baidu.com/30\")\na\n[p for p in a]\n\n\n\nCaution\nset the python3 of the virtualenv with the CAP_NET_RAW capability!\nsudo setcap 'CAP_NET_RAW+eip CAP_NET_ADMIN+eip' /dpt/.pyenv/versions/miniconda3-3.11-24.1.2-0/envs/can/bin/python3.11\n\n# sniff(filter=\"icmp and host 10.10.10.28\", count=2)\n\n\nif blue_pill:  # not a virtual machine\n    # install vcan interface with encrypted password to sudo \n    os.system(\"gpg -d -q ~/.sshpasswd.gpg | sshpass -v sudo modprobe vcan\")\n    # sshpass -v -p asdf sudo ip link add dev vcan0 type vcan\n    os.system(\"gpg -d -q ~/.sshpasswd.gpg | sshpass -v sudo ip link add dev vcan0 type vcan\")\n    os.system(\"ip link show vcan0\")\n    # !gpg -d -q ~/.sshpasswd.gpg | sshpass -v sudo ip link set vcan0 type vcan bitrate 500000  # vcan does not support set bitrate on command line!\n    # !sshpass -p asdf sudo ip link add dev vcan0 type vcan\n    os.system(\"gpg -d -q ~/.sshpasswd.gpg | sshpass -v sudo ip link set up vcan0\")\n    # !sshpass -v -p asdf sudo ip link set up vcan0\nelse:  # in a virtual machine (Github workflow)\n    os.system(\"sudo modprobe vcan\")\n    # sshpass -v -p asdf sudo ip link add dev vcan0 type vcan\n    os.system(\"sudo ip link add dev vcan0 type vcan\")\n    os.system(\"ip link show vcan0\")\n    # !gpg -d -q ~/.sshpasswd.gpg | sshpass -v sudo ip link set vcan0 type vcan bitrate 500000  # vcan does not support set bitrate on command line!\n    # !sshpass -p asdf sudo ip link add dev vcan0 type vcan\n    os.system(\"sudo ip link set up vcan0\")\n\n\nload_layer(\"can\")\nconf.contribs['CANSocket'] = {'use-python-can': False}\nload_contrib(\"cansocket\")\n\nsocket = CANSocket(channel='vcan0',\n                receive_own_messages=True)\n\n\npacket = CAN(identifier=0x123, data=b'12345678')\npacket.show2()\n\n\nsocket.send(packet)\nrx_packet = socket.recv()\nrx_packet.show2()\n\n\n\nCCP via Scapy\n\nload_contrib(\"automotive.ccp\")\n\n\npkt = CCP(identifier=0x700)/CRO(ctr=1)/CONNECT(station_address=0x02)\npkt.show2()\n\n\npkt = CCP(identifier=0x711)/CRO(ctr=2)/GET_SEED(resource=2)\npkt.show2()\n\n\npkt = CCP(identifier=0x711)/CRO(ctr=3)/UNLOCK(key=b\"123456\")\npkt.show2()\n\n\npkt = CCP(identifier=0x711)/CRO(ctr=1)/GET_DAQ_SIZE()\nsock = CANSocket(bustype='socketcan', channel='vcan0', receive_own_messages=True)\n\n\n## another socket in the same process cannot receive the packet sent by the first socket\n# socket2 = CANSocket(channel='vcan0')\n\n\n## same socket cannot receive the packet sent by itself\n# rx_packet = socket2.recv()\n\n\n# rx_packet.show2()\n\n\n# socket.sr1(packet, timeout=1)\n\n\n# rx_packet = socket.recv()\nwrpcap(\"./scapypcaptest.pcap\", packet)\n\n\nif blue_pill:\n    # close and remove vcan0\n    os.system(\"gpg -d -q ~/.sshpasswd.gpg | sshpass -v sudo ip link set down vcan0\")\n    # delete vcan0\n    os.system(\"gpg -d -q ~/.sshpasswd.gpg | sshpass -v sudo ip link delete vcan0\")    \nelse:\n    # close and remove vcan0\n    os.system(\"sudo ip link set down vcan0\")\n    # delete vcan0\n    os.system(\"sudo ip link delete vcan0\")",
    "crumbs": [
      "XCP"
    ]
  },
  {
    "objectID": "vcantest/receive_messasge.html",
    "href": "vcantest/receive_messasge.html",
    "title": "receive_message",
    "section": "",
    "text": "from pprint import pprint\n\n\n\nget_argparser\n\n get_argparser ()\n\n*summary get CAN bus, dbc config and the message to send\nReturns: argparse.ArgumentParser: description*\n\ndb = cantools.database.load_file('../../res/motohawk_new.dbc')\ndb.messages\nexample_message: MessageTpl = db.get_message_by_name('ExampleMessage')\npprint(example_message.signals)\n# pprint(example_message.__dict__)\nexample_message.frame_id\n\n\n!gpg -d -q ~/.sshpasswd.gpg | sshpass -v sudo modprobe vcan\n!gpg -d -q ~/.sshpasswd.gpg | sshpass -v sudo ip link add dev vcan0 type vcan\n# sshpass -v -p asdf sudo ip link add dev vcan0 type vcan\n!ip link show vcan0\n# !gpg -d -q ~/.sshpasswd.gpg | sshpass -v sudo ip link set vcan0 type vcan bitrate 500000  # vcan Does not SUPPORT set bitrate on command line!\n# !sshpass -p asdf sudo ip link add dev vcan0 type vcan\n!gpg -d -q ~/.sshpasswd.gpg | sshpass -v sudo ip link set up vcan0\n# !sshpass -v -p asdf sudo ip link set up vcan0\n\n\ndata_dict ={'Temperature': 250.1, 'AverageRadius': 3.2, 'Enable': 1}\ndata_json_bytes = json.dumps(data_dict).encode('utf-8')\ndata_json_bytes\njson.loads(data_json_bytes.decode())\n\ncan_data = example_message.encode({'Temperature': 250.1, 'AverageRadius': 3.2, 'Enable': 1})\nexample_message.decode(can_data)\n\n\nf = io.BytesIO(data_json_bytes)\n\n\nbus = can.interface.Bus(bustype='socketcan', channel='vcan0', bitrate=250000)\ndata = example_message.encode({'Temperature': 250.1, 'AverageRadius': 3.2, 'Enable': 1})\nmessage_to_send = can.Message(arbitration_id=example_message.frame_id, data=data, is_extended_id=False)     \n# can_bus.send(message)\n\n\nmanager = Manager()\nmessage_proxy = manager.dict()\n\n\n\n\nreceive_msg\n\n receive_msg (db:cantools.database.can.database.Database, message:str,\n              channel:str, bitrate:int, bus_type:str)\n\n\n\n\nreceive_message\n\n receive_message (message_proxy:multiprocessing.managers.DictProxy,\n                  bus:&lt;function Bus&gt;)\n\n\nos.getcwd()\n\n\n# proc = subprocess.Popen(['python', 'message_send.py'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)\n# print(f'PARENT: {proc.pid} before signaling child')\n# sys.stdout.flush()\n# time.sleep(1)\n\n\n# receive_message(message_proxy, bus)\n\n\n# print(f'PARENT: {proc.pid} signaling child')\n# sys.stdout.flush()\n# os.kill(proc.pid, signal.SIGUSR1)\n# stdout_value = proc.communicate()[0].decode('utf-8')\n# print(f'stdout: {repr(stdout_value)}')\n\n\n# datetime.fromtimestamp(message_proxy['timestamp']),db.decode_message(message_proxy['arbitration_id'],message_proxy['data'])\n\n\n# close and remove vcan0\n# !sshpass -v -p  asdf sudo ip link delete vcan0 \n\n!gpg -d -q ~/.sshpasswd.gpg | sshpass -v sudo ip link set down vcan0\n\n\n!gpg -d -q ~/.sshpasswd.gpg | sshpass -v sudo ip link delete vcan0",
    "crumbs": [
      "vcantest",
      "receive_message"
    ]
  },
  {
    "objectID": "vcantest/send_receive_message_mp.html",
    "href": "vcantest/send_receive_message_mp.html",
    "title": "candycan",
    "section": "",
    "text": "from IPython.core.interactiveshell import InteractiveShell\nInteractiveShell.ast_node_interactivity = \"all\"\n\n\n\nimport time\nimport os\nfrom multiprocessing import Process, Event\nfrom multiprocessing import synchronize, Manager\nfrom multiprocessing.managers import DictProxy\nfrom typing import Optional\n# import threading\n\n\nimport cantools\nimport can\n# from can import Message\nfrom cantools.database import Message\nfrom can.interface import Bus  # virtual interface for testing\n# from can.interfaces.udp_multicast.bus import GeneralPurposeUdpMulticastBus as GPUDPMCBus\n# from can.interfaces.udp_multicast import UdpMulticastBus\n\n\ndb = cantools.database.load_file('../res/motohawk_new.dbc')\ndb.messages\nexample_message = db.get_message_by_name('ExampleMessage')\nexample_message.signals\n# pprint(example_message.__dict__)\nexample_message.frame_id\nexample_message.signal_groups\nexample_message.signal_tree\n\n\n!gpg -d -q ~/.sshpasswd.gpg | sshpass -v sudo modprobe vcan\n\n\n!gpg -d -q ~/.sshpasswd.gpg | sshpass -v sudo ip link add dev vcan0 type vcan\n# sshpass -v -p asdf sudo ip link add dev vcan0 type vcan\n\n\n!ip link show vcan0\n\n\n# !gpg -d -q ~/.sshpasswd.gpg | sshpass -v sudo ip link set vcan0 type vcan bitrate 500000  # vcan Does not SUPPORT set bitrate on command line!\n# !sshpass -p asdf sudo ip link add dev vcan0 type vcan\n\n\n# !gpg -d -q ~/.sshpasswd.gpg | sshpass -v sudo ip link set up vcan0\n!gpg -d -q ~/.sshpasswd.gpg | sshpass -v sudo ip link set vcan0 up type vcan\n# !gpg -d -q ~/.sshpasswd.gpg | sshpass -v sudo ip link set vcan0 up type vcan  bitrate 500000  # vcan Does not SUPPORT set bitrate on command line!\n# !sshpass -v -p asdf sudo ip link set up vcan0\n\n\nbus = Bus(bustype='socketcan', channel='vcan0', bitrate=250000) # interface='virtual'\n# bus = GPUDPMCBus(group=UdpMulticastBus.DEFAULT_GROUP_IPv6, port=43113, hop_limit=1)\n# bus = UdpMulticastBus(group=UdpMulticastBus.DEFAULT_GROUP_IPv6)\ndata = example_message.encode({'Temperature': 250.1, 'AverageRadius': 3.2, 'Enable': 1})\nmessage_to_send = can.Message(arbitration_id=example_message.frame_id, data=data, is_extended_id=False)     \nmessage_to_send\nbus\nbus.fileno()\n# bus.protocol\nmessage_to_send.data\nmessage_to_send.arbitration_id\n\n\nmanager = Manager()\nmessage_proxy = manager.dict()\n\n\n# def receive_message(message_proxy: DictProxy, bus_channel:str='vcan0', bitrate:int=25000):\ndef receive_message(message_proxy: DictProxy, bus:Bus):\n    print('entering receive subprocess')\n    # bus = Bus(bustype='socketcan', channel=bus_channel, bitrate=bitrate)\n    # os.setsid()\n    print(f'bus: {bus.fileno()} {bus}')\n    msg:Message = bus.recv()\n    print(f'message received: {msg}')\n    message_proxy['timestamp'] = msg.timestamp\n    message_proxy['arbitration_id'] = msg.arbitration_id\n    message_proxy['data']=msg.data\n\n\n# def send_message(message: can.Message, done: synchronize.Event, bus_channel:str='vcan0', bitrate:int=25000, timeout: Optional[float]=None)-&gt;None:\ndef send_message(message: can.Message, done: synchronize.Event, bus:Bus, timeout: Optional[float]=None)-&gt;None:\n    print(\"entering send subprocess\")\n    # os.setsid()  # create new process group, become session leader, otherwise a process in a same session could not receive signal from the main process\n    os.setpgrp()\n    print((os.getpid(), os.getsid(os.getpid())))\n    # bus = Bus(bustype='socketcan', channel=bus_channel, bitrate=bitrate)\n    print(f'bus: {bus.fileno()}, {bus}')\n    bus.send(message)\n    print('message sent and waiting')\n    start = time.time_ns()\n    done.wait()\n    elapsed = (time.time_ns()-start)//1e6\n    print(f'elapsed time: {elapsed:.3f}ms')\n\n\nos.getcwd()\nbus.fileno()\nbus\nos.getpid(),os.getsid(os.getpid())\n\n\n# shm = shared_memory.SharedMemory(create=True, size=1024)\n\n\n# def send_message_wrapper(message: Message, bus: Bus)-&gt;None:\ntimeout = None\ndone = Event()\n# message_to_send\nprint(\"before\")\nprocess_send = Process(target=send_message, name=\"Sending CAN messasge\", args=(message_to_send, done, bus))\n# process_send.start()\n# process_send.pid, process_send\n# message_to_send\n\n\n# receive_message(message_proxy, bus)\n# process_receive = Process(target=receive_message, name=\"Receiving CAN message\", args=(message_proxy,bus))\n# process_receive.start()\n# process_receive\n\n\ndone.set()\n\n\n# process_send\n\n\n# datetime.fromtimestamp(message_proxy['timestamp']),db.decode_message(message_proxy['arbitration_id'],message_proxy['data'])\n\n\n# Process(target=receive_message, args=(message_proxy, bus, done, timeout)).start()\n\n\n# try:\n#   recv_message = Message(arbitration_id=recv_message_proxy['arbitration_id'], data=recv_message_proxy['data'], is_extended_id=False)\n# except KeyError:\n#   print('KeyError')\n\n\n# message = bus.recv(timeout=2)\n# if message is not None:\n#   message = can.Message(arbitration_id=example_message.frame_id, data=data, is_extended_id=False)     \n#   db.decode_message(message.arbitration_id, message.data)\n# else:\n#   print('no message received')\n\n\n# done.set()\n\n\n# import time\n# import can\n# from can.interfaces.udp_multicast import UdpMulticastBus\n\n# # The bus can be created using the can.Bus wrapper class or using UdpMulticastBus directly\n# with can.Bus(channel=UdpMulticastBus.DEFAULT_GROUP_IPv4, interface='udp_multicast') as bus_1:\n                \n#   # bus_2 = can.Bus(channel=UdpMulticastBus.DEFAULT_GROUP_IPv6, interface='udp_multicast')\n#   bus_2 = UdpMulticastBus(channel=UdpMulticastBus.DEFAULT_GROUP_IPv4)\n\n#     # register a callback on the second bus that prints messages to the standard out\n#   notifier = can.Notifier(bus_2, [can.Printer()])\n    \n#   message = can.Message(arbitration_id=0x123, data=[1, 2, 3])\n#   bus_1.send(message)\n#   # time.sleep(2.0)\n#   # notifier\n#   # msg = bus_2.recv(timeout=1)\n#   # print(msg)\n\n\n#     # create and send a message with the first bus, which should arrive at the second one\n#     # give the notifier enough time to get triggered by the second bus\n    \n#   time.sleep(2.0)\n\n#     # msg = bus_2.recv(timeout=2)\n#     # give the notifier enough time to get triggered by the second bus\n#     # print(msg)\n#   bus_2.shutdown()\n\n\n# close and remove vcan0\n# !sshpass -v -p  asdf sudo ip link delete vcan0 \n\n!gpg -d -q ~/.sshpasswd.gpg | sshpass -v sudo ip link set down vcan0\n\n\n!gpg -d -q ~/.sshpasswd.gpg | sshpass -v sudo ip link delete vcan0",
    "crumbs": [
      "vcantest",
      "send_receive_message_mp.html"
    ]
  },
  {
    "objectID": "vcantest/ccp.scapy.html",
    "href": "vcantest/ccp.scapy.html",
    "title": "CCP over Scapy",
    "section": "",
    "text": "# #|export\n# from candycan.data_link_socketcan import done, send_msg",
    "crumbs": [
      "vcantest",
      "CCP over Scapy"
    ]
  },
  {
    "objectID": "vcantest/ccp.scapy.html#types-definition",
    "href": "vcantest/ccp.scapy.html#types-definition",
    "title": "CCP over Scapy",
    "section": "Types definition",
    "text": "Types definition\n\n\ncheck_can_type\n\n check_can_type (c:str)\n\n*Summary Check if the CAN type is valid\nArgs: can_type (str): CAN type to be checked\nReturns: str: CAN type if valid\nRaises: ValueError: if CAN type is invalid*\n\n# # CanType\n# native_can_type = CanType('NATIVE')\n# native_can_type.lower()\n# isinstance(native_can_type, CanType)\n# isinstance('NATIVE', CanType)\n\n\n\n\ncheck_bus_type\n\n check_bus_type (b:str)\n\n*Summary Check if the CAN bus type is valid\nArgs: b (str): Python CAN bus type to be checked\nReturns: str: Python CAN bus type if valid\nRaises: ValueError: if CAN bus type is invalid*\n\n\n\nCANFilter\n\n CANFilter (can_id:typing.Annotated[int,Gt(gt=0)]=630,\n            can_mask:typing.Annotated[int,Gt(gt=0)]=2047)\n\n*Summary CAN filter for Python CAN bus\nAttributes: can_id (int): CAN message ID can_mask (int): CAN message mask*\n\n\n\nScapyCANSpecs\n\n ScapyCANSpecs (can_type:typing.Annotated[str,AfterValidator(func=&lt;functio\n                ncheck_can_typeat0x7f8f4c8b22a0&gt;)]='NATIVE', bus_type:typi\n                ng.Annotated[str,AfterValidator(func=&lt;functioncheck_bus_ty\n                peat0x7f8f4c8b2520&gt;)]='VIRTUAL', channel_serial_number:typ\n                ing.Annotated[int,Ge(ge=0),Lt(lt=500)]=3,\n                download_can_id:typing.Annotated[int,Gt(gt=0)]=630,\n                upload_can_id:typing.Annotated[int,Gt(gt=0)]=630,\n                can_filters:Optional[list[__main__.CANFilter]]=None, bit_r\n                ate:typing.Annotated[int,Gt(gt=0),Lt(lt=1000000)]=500000, \n                time_out:typing.Annotated[float,Gt(gt=0.0),Lt(lt=10.0)]=1.\n                0, station_address:typing.Annotated[int,Ge(ge=0),Lt(lt=255\n                )]=0,\n                cntr:typing.Annotated[int,Ge(ge=0),Lt(lt=1000000)]=0,\n                receive_own_messages:bool=True, download_upload:bool=True,\n                diff_mode:bool=False, diff_threshold:float=0.001,\n                last_download_data:Optional[candycan.a2l.XCPData]=None)\n\n*Usage docs: https://docs.pydantic.dev/2.7/concepts/models/\nA base class for creating Pydantic models.\nAttributes: class_vars: The names of classvars defined on the model. private_attributes: Metadata about the private attributes of the model. signature: The signature for instantiating the model.\n__pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n__pydantic_core_schema__: The pydantic-core schema used to build the SchemaValidator and SchemaSerializer.\n__pydantic_custom_init__: Whether the model has a custom `__init__` function.\n__pydantic_decorators__: Metadata containing the decorators defined on the model.\n    This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n__pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n    __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n__pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n__pydantic_post_init__: The name of the post-init method for the model, if defined.\n__pydantic_root_model__: Whether the model is a `RootModel`.\n__pydantic_serializer__: The pydantic-core SchemaSerializer used to dump instances of the model.\n__pydantic_validator__: The pydantic-core SchemaValidator used to validate instances of the model.\n\n__pydantic_extra__: An instance attribute with the values of extra fields from validation when\n    `model_config['extra'] == 'allow'`.\n__pydantic_fields_set__: An instance attribute with the names of fields explicitly set.\n__pydantic_private__: Instance attribute with the values of private attributes set on the model instance.*\n\ntry:\n    m = ScapyCANSpecs(can_type='NATIVE', bus_type='VIRTUAL')\nexcept ValidationError as exc:\n    print(exc)\n\npprint(m.model_dump())\n\n\ndef emulate_call(m: ScapyCANSpecs):\n    m.cntr += 1\n\nfor i in range(3):\n    emulate_call(m)\n    print(f\"{i}: counter {m.cntr}\")\n\n\nxcp_calib_from_xcpjson = Get_XCPCalib_From_XCPJSon(args.input)\nxcp_calib_from_xcpjson\n\n\nxcp_data = Generate_Init_XCPData_From_A2L(\n    a2l=args.a2l, keys=args.leaves, node_path=args.node_path\n)\n\n#  address from xcp data file should align with the address from xcp calib file\ntest_eq(xcp_data.address, xcp_calib_from_xcpjson.data[0].address)\n\n# validate the model\ntry:\n    XCPData.model_validate(xcp_data)\nexcept ValidationError as exc:\n    print(exc)\n\n\n# type(args.channel), type(args.download_id), args.upload_id, args.download, args.diff_flashing\n\n\nxcp_data.value = xcp_calib_from_xcpjson.data[0].value\npprint(xcp_data)\nxcp_data.value_array_view[0,2], xcp_data.value_array_view[2,0]\n\n\nxcp_calib = XCPCalib(\n    config=XCPConfig(\n        channel=args.channel_serial_number, download=args.download_can_id, upload=args.upload_can_id\n    ),\n    data=[xcp_data],\n)\n\n\npprint(xcp_calib)\n\n\nnpa =  xcp_calib.data[0].value_array_view\nnpa.shape, npa.dtype, npa\nlen(xcp_calib.data[0].value_bytes), xcp_calib.data[0].value_bytes\n\nlen(npa.tobytes()), npa.tobytes()\ntest_eq(npa.tobytes(), xcp_calib.data[0].value_bytes)\nxcp_calib.data[0].value\n\n\n# buffer = [i.hex() for x in npa for i in x]\n# # buffer[::-1]\n# len(buffer)\n# buffer\n\n\n# buffer = npa.tobytes()\n\n# pprint(buffer), len(buffer)\n# xcp_calib.data[0].value, len(xcp_calib.data[0].value)\n\n\naddr = bytes('7000aa2a', 'utf-8')\na = 0x7000aa2a\na\n\n\nnpb = npa[::-1]\n# npb\nbuffer = [struct.pack(\"&lt;f\", x) for x in np.nditer(npa)]\n# buffer\nlen(buffer)\n\n\n\ninvestigate int type and type size\n\nd = xcp_calib.data[0]\nadd = int(d.address, base=16)\nd.address, add\nhex(add), type(add), sys.getsizeof(add)\nstruct.calcsize('h'), struct.calcsize('i'), struct.calcsize('l'), struct.calcsize('L')\ntype(d.address),len(d.address)\n\n\n\n\nnpa_to_packed_buffer\n\n npa_to_packed_buffer (a:numpy.ndarray)\n\n*convert a numpy array to a packed string buffer for flashing TODO: implementation as numpy ufunc\nArgs: a (np.ndarray): input numpy array for flashing\nReturns: str: packed string buffer for flashing*\n\n# buffer = [struct.pack(\"&lt;f\", x).hex() for x in np.nditer(npa)]\n# buffer[::-1]\n# len(buffer)\n# buffer\n# data = ''.join(buffer)\ndata = npa_to_packed_buffer(npa)\ntest_eq(data, xcp_calib.data[0].value)\n# data",
    "crumbs": [
      "vcantest",
      "CCP over Scapy"
    ]
  },
  {
    "objectID": "vcantest/ccp.scapy.html#convert-a-numpy-array-to-a-continuous-hex-string",
    "href": "vcantest/ccp.scapy.html#convert-a-numpy-array-to-a-continuous-hex-string",
    "title": "CCP over Scapy",
    "section": "convert a numpy array to a continuous hex string",
    "text": "convert a numpy array to a continuous hex string\n\n# npa.astype(np.float32).tobytes().hex()\nbuffer = npa.astype(np.float32).tobytes().hex()  ## == npa_to_packed_buffer(npa)\nbuffer, len(buffer)\ntest_eq(buffer, xcp_calib.data[0].value)\n\n\n\nflash_xcp\n\n flash_xcp (xcp_calib:candycan.a2l.XCPCalib,\n            data:pandas.core.frame.DataFrame, diff_flashing:bool=False,\n            download:bool=True)\n\n*Summary Flash XCP data to target\nArgs: xcp_calib (XCPCalib): XCP calibration as template, contains all the meta information except for data xcp_data (pd.DataFrame): input XCP data to be flashed, replace the value in xcp_calib diff_flashing (bool): Use differential flashing download (bool): Download or upload*",
    "crumbs": [
      "vcantest",
      "CCP over Scapy"
    ]
  },
  {
    "objectID": "vcantest/ccp.scapy.html#cro-for-connection",
    "href": "vcantest/ccp.scapy.html#cro-for-connection",
    "title": "CCP over Scapy",
    "section": "CRO for connection",
    "text": "CRO for connection\n\n# sock.send(cro)\n# ctr += 1\n# rx_cro = sock.recv()\n# rx_cro.canvas_dump()\nsock = CANSocket(busytpe='socketcan', channel=f'can{args.channel_serial_number}', basecls=CCP, receive_own_messages=True)\n# sock = CANSocket(busytpe='socketcan', channel=f'can{args.channel_serial_number}', basecls=CCP)\nsock\n\n\nget CCP version\n\nctr = 0\n\n\n# cro = CCP(identifier=xcp_calib.config.download_can_id)/CRO(ctr=ctr)/CONNECT(station_address=0x01)  # or 0x00?\ncro = CCP(identifier=xcp_calib.config.download_can_id)/CRO(ctr=ctr)/GET_CCP_VERSION()  # or 0x00?\ncro.show2()\ncro.canvas_dump()\n\n\ndto = sock.sr1(cro) #, timeout=5)\nctr += 1\ndto.show2()\ndto.canvas_dump()\n\n\ndto\n\n\n\nsend connect CRO\n\nprint(f'ctr: {ctr}')\n\n\n# cro = CCP(identifier=xcp_calib.config.download_can_id)/CRO(ctr=ctr)/CONNECT(station_address=0x01)  # or 0x00?\ncro = CCP(identifier=xcp_calib.config.download_can_id)/CRO(ctr=0)/CONNECT()  # or 0x00?\ncro.show2()\ncro.canvas_dump()\nprint(f\"ctr: {ctr}\")\n\n\ndto = sock.sr1(cro) #, timeout=5)\nctr += 1 # 1\n\n\ndto.show2()\ndto.canvas_dump()\n\n\ndto",
    "crumbs": [
      "vcantest",
      "CCP over Scapy"
    ]
  },
  {
    "objectID": "vcantest/ccp.scapy.html#download-from-target",
    "href": "vcantest/ccp.scapy.html#download-from-target",
    "title": "CCP over Scapy",
    "section": "Download from target",
    "text": "Download from target\n\nxcp_calib.data\n\n\nd = xcp_calib.data[0]\nd.address, d.type_size, d.dim, d.value_array_view, d.value_bytes\nlen(d.value_bytes )\nd.value",
    "crumbs": [
      "vcantest",
      "CCP over Scapy"
    ]
  },
  {
    "objectID": "vcantest/ccp.scapy.html#set-mta",
    "href": "vcantest/ccp.scapy.html#set-mta",
    "title": "CCP over Scapy",
    "section": "set mta",
    "text": "set mta\n\nd.address,ctr\n\n\n# ctr = 0\nprint(f\"ctr: {ctr}\")\ncro = CCP(identifier=xcp_calib.config.download_can_id)/CRO(ctr=0)/SET_MTA(address=int(d.address, 16))\ncro.show2()\ncro.payload\n\n\nsock\n\n\ndto = sock.sr1(cro)\nctr += 1\n\n\ndto.show2()\ndto.canvas_dump()\ndto.payload\n\n\nlen_in_bytes = d.type_size * d.dim[0] * d.dim[1]\nprint(f\"len_in_bytes: {len_in_bytes} = type_size: {d.type_size} x dim: {d.dim}\")\n\ndownload_times = len_in_bytes // 6\nlast_download_size = len_in_bytes % 6\nprint(f\"download_times: {download_times}, last_download_size: {last_download_size}\")\n\n\nd.value_bytes\nlen(d.value_bytes)\ntile0 = d.value_bytes[0:6]\nlen(tile0), tile0, tile0.hex(), type(tile0)\ntile1 = d.value_bytes[6:12]\nlen(tile1), tile1, tile1.hex()\n\n\ntile0 = d.value_bytes[0:4]\nlen(tile0), tile0, tile0.hex(), type(tile0), struct.unpack(\"&lt;f\", tile0)\ntile1 = d.value_bytes[4:8]\nlen(tile1), tile1, tile1.hex(), struct.unpack(\"&lt;f\", tile1)\ntile2 = d.value_bytes[8:12]\nlen(tile1), tile2, tile2.hex(), struct.unpack(\"&lt;f\", tile2)\nst = 2*17*4\ntile3 = d.value_bytes[st:st+4]\nlen(tile1), tile3, tile3.hex(), struct.unpack(\"&lt;f\", tile3)\nd.value_array_view[2,0]\ntest_eq(struct.unpack(\"&lt;f\", tile3), d.value_array_view[2,0])\n\n\ntile3.hex(), tile3.hex().encode()\n\n\ntype(tile3)\nlist(tile3)\n\n\nba_uploaded = bytearray()\nba_uploaded += tile3\nba_uploaded\nba_uploaded += tile2\nba_uploaded += tile1\nba_uploaded, len(ba_uploaded)\n\n\nba_uploaded = bytearray()\nlen_in_bytes = d.type_size * d.dim[0] * d.dim[1]\ndownload_times = len_in_bytes // 6\nlast_download_size = len_in_bytes % 6\nfor tile in range(download_times):\n    ba_uploaded += d.value_bytes[tile*6:(tile+1)*6]\nif last_download_size:\n    ba_uploaded += d.value_bytes[download_times*6:download_times*6+last_download_size]\n\nlen(ba_uploaded), ba_uploaded.hex()\ntest_eq(ba_uploaded, d.value_bytes)\ntest_eq(ba_uploaded.hex(), d.value)\nba_uploaded.hex()",
    "crumbs": [
      "vcantest",
      "CCP over Scapy"
    ]
  },
  {
    "objectID": "vcantest/ccp.scapy.html#loop-over-xcpcalib-data-array",
    "href": "vcantest/ccp.scapy.html#loop-over-xcpcalib-data-array",
    "title": "CCP over Scapy",
    "section": "loop over XCPCalib data array",
    "text": "loop over XCPCalib data array\n\nprint(f'payload: {d.value_bytes[0:6]}')\nprint(f'ctr: {ctr}')\ncro = CCP(identifier=xcp_calib.config.download_can_id)/CRO(ctr=0)/DNLOAD_6(data=d.value_bytes[0:6])\n# if i%100==0:\n    # print(f\"i: {i}, ctr: {ctr} cro: {cro}\")\ncro.show2()\n    # cro.payload\n# sent_bytes = sock.send(cro)\n# rx_cro = sock.recv()\ndto = sock.sr1(cro)\nctr += 1\ndto.show2()\n\n\ncro.canvas_dump()\ndto.canvas_dump()\n\n\nprint(f'payload: {d.value_bytes[6:12]}')\nprint(f'ctr: {ctr}')\ncro = CCP(identifier=xcp_calib.config.download_can_id)/CRO(ctr=0)/DNLOAD_6(data=d.value_bytes[6:12])\n# if i%100==0:\n    # print(f\"i: {i}, ctr: {ctr} cro: {cro}\")\ncro.show2()\n    # cro.payload\n# sent_bytes = sock.send(cro)\n# rx_cro = sock.recv()\ndto = sock.sr1(cro)\nctr += 1\ndto.show2()\n\n\nfor i in range(download_times):\n    print(f'payload: {d.value_bytes[i*6:(i+1)*6]}')\n    print(f'ctr: {ctr}')\n    cro = CCP(identifier=xcp_calib.config.download_can_id)/CRO(ctr=ctr)/DNLOAD_6(data=d.value_bytes[i*6:(i+1)*6])\n    # if i%100==0:\n        # print(f\"i: {i}, ctr: {ctr} cro: {cro}\")\n    cro.show2()\n        # cro.payload\n    # sent_bytes = sock.send(cro)\n    # rx_cro = sock.recv()\n    dto = sock.sr1(cro)\n    ctr += 1\n    dto.show2()\n    assert dto.return_code == 0x00\n    # rx_cro.show2()\n    # dto = sock.sr1(cro)\n    # dto.show2()\n    # assert dto.return_code == 0x00\ni\ncro.canvas_dump()\ndto.canvas_dump()\n\n\nstart_index = download_times * 6\ncro = CCP(identifier=xcp_calib.config.download_can_id)/CRO(ctr=ctr)/DNLOAD(data=d.value_bytes[start_index:start_index+last_download_size])\ncro.show2()\ncro.payload\ncro.canvas_dump()\n# sent_bytes = sock.send(cro)\ndto = sock.sr1(cro)\nctr += 1 \ndto.canvas_dump()",
    "crumbs": [
      "vcantest",
      "CCP over Scapy"
    ]
  },
  {
    "objectID": "vcantest/ccp.scapy.html#disconnect-target-ecu",
    "href": "vcantest/ccp.scapy.html#disconnect-target-ecu",
    "title": "CCP over Scapy",
    "section": "Disconnect target ecu",
    "text": "Disconnect target ecu\n\ncro = CCP(identifier=xcp_calib.config.download_can_id)/CRO(ctr=ctr)/DISCONNECT(station_address=0x00)\ncro.show2()\ncro.canvas_dump()\n# bytes_sent = sock.send(cro)\ndto = sock.sr1(cro)\nctr += 1\ndto.show2()\ndto.canvas_dump()",
    "crumbs": [
      "vcantest",
      "CCP over Scapy"
    ]
  },
  {
    "objectID": "vcantest/ccp.scapy.html#three-context-managers-for-ccp",
    "href": "vcantest/ccp.scapy.html#three-context-managers-for-ccp",
    "title": "CCP over Scapy",
    "section": "Three context managers for CCP",
    "text": "Three context managers for CCP\n\n\ncan_context\n\n can_context (can_specs:__main__.ScapyCANSpecs)\n\n*Summary Context manager for scapy CAN socket\nArgs: can_specs (ScapyCANSpecs): CAN specs including can type, bus type, channel, etc.\nYields: CANSocket: CAN socket object*\n\n\n\nSET_MTA_context\n\n SET_MTA_context (can_specs:__main__.ScapyCANSpecs,\n                  sock:scapy.contrib.cansocket_native.NativeCANSocket,\n                  data:candycan.a2l.XCPData)\n\n*Summary Context manager for scapy set_mta\nArgs: channel (str): CAN channel to use, default is vcan0\nYields: CAN: packdet for CAN message*\n\n\n\nXLOAD_context\n\n XLOAD_context (can_specs:__main__.ScapyCANSpecs,\n                sock:scapy.contrib.cansocket_native.NativeCANSocket,\n                data:candycan.a2l.XCPData, start_index:int, tile_size:int)\n\n*Summary Context manager for scapy load (download or upload)\nArgs: channel (str): CAN channel to use, default is vcan0\nYields: CANSocket: CAN socket object*",
    "crumbs": [
      "vcantest",
      "CCP over Scapy"
    ]
  },
  {
    "objectID": "vcantest/ccp.scapy.html#downloading-and-uploading-with-context-managers",
    "href": "vcantest/ccp.scapy.html#downloading-and-uploading-with-context-managers",
    "title": "CCP over Scapy",
    "section": "Downloading and uploading with context managers",
    "text": "Downloading and uploading with context managers\n\n\nupload_calib_data2\n\n upload_calib_data2 (xcp_calib:candycan.a2l.XCPCalib,\n                     can_specs:__main__.ScapyCANSpecs)\n\n*Summary Upload XCP calibration data from target to host, the result will update the xcp_calib.data field\nArgs: xcp_calib (XCPCalib): XCP calibration to be uploaded from the target to host diff_flashing (bool): Use differential flashing*\n\n\n\ndownlod_calib_data2\n\n downlod_calib_data2 (xcp_calib:candycan.a2l.XCPCalib,\n                      can_specs:__main__.ScapyCANSpecs)\n\n*Summary Download XCP calibration data to target use scapy_can_context\nArgs: xcp_calib (XCPCalib): XCP calibration to be downloaded into the target*\n\ncan_filters = [{'can_id': xcp_calib.config.upload_can_id, 'can_mask': 0x7FF}]\ncan_specs = ScapyCANSpecs(can_type='NATIVE', \n                        bus_type='SOCKET', \n                        channel_serial_number=3,\n                        download_can_id=xcp_calib.config.download_can_id,\n                        upload_can_id=xcp_calib.config.upload_can_id,\n                        can_filters=can_filters,\n                        bit_rate=500_000,\n                        time_out=1.0,\n                        station_address=0x00,\n                        cntr=0,\n                        receive_own_messages=True,\n                        download_upload=True\n                        )\ncan_specs\ncan_specs.model_dump()\n\n\nxcp_calib.config.channel = 0\nxcp_calib\n\n\n# TODO cannot run test on CCP without a real or emulated ECU \n# downlod_calib_data2(xcp_calib, can_type='NATIVE', bus_type='VIRTUAL', bit_rate=500_000, timeout=1.0, station_address=0x00, diff_flashing=False)",
    "crumbs": [
      "vcantest",
      "CCP over Scapy"
    ]
  },
  {
    "objectID": "vcantest/ccp.scapy.html#test-downloading-and-uploading",
    "href": "vcantest/ccp.scapy.html#test-downloading-and-uploading",
    "title": "CCP over Scapy",
    "section": "Test downloading and uploading",
    "text": "Test downloading and uploading\n\nxcp_calib_from_xcpjson = Get_XCPCalib_From_XCPJSon(args.input)\n\nargs.download_can_id = xcp_calib_from_xcpjson.config.download_can_id\nargs.upload_can_id = xcp_calib_from_xcpjson.config.upload_can_id\nargs.channel_serial_number = xcp_calib_from_xcpjson.config.channel\n\nxcp_data = Generate_Init_XCPData_From_A2L(\n    a2l=args.a2l, keys=args.leaves, node_path=args.node_path\n)  # initial xcp_data has value 0\ntry:\n    XCPData.model_validate(xcp_data)\nexcept ValidationError as exc:\n    print(exc)\n\n# emulate torque table input as numpy array\nxcp_data_value_npa = xcp_calib_from_xcpjson.data[0].value_array_view\nxcp_data.value = xcp_data_value_npa.astype(np.float32).tobytes().hex()\npprint(xcp_data)\n\nxcp_calib = XCPCalib(\n    config=XCPConfig(\n        channel=args.channel_serial_number, download=args.download_can_id, upload=args.upload_can_id\n    ),\n    data=[xcp_data],\n)\npprint(xcp_calib)\n\ncan_filters = [{'can_id': xcp_calib.config.upload_can_id, 'can_mask': 0x7FF}]\ncntr = 0\ncan_specs = ScapyCANSpecs(can_type=args.can_type,\n                        bus_type=args.bus_type,\n                        channel_serial_number=args.channel_serial_number,\n                        download_can_id=xcp_calib.config.download_can_id,\n                        upload_can_id=xcp_calib.config.upload_can_id,\n                        can_filters=can_filters,\n                        bit_rate=args.bit_rate,\n                        time_out=args.time_out,\n                        station_address=args.station_address,\n                        cntr=cntr,\n                        receive_own_messages=True,\n                        download_upload=args.download,  # CCP Upload mode\n                        diff_mode = args.diff_mode,\n                        diff_threshold= args.diff_threshold\n                        )\n\n\ncan_specs\n\n\n# test uploading\n# can_specs.download_upload = False                        \n# upload_calib_data2(xcp_calib=xcp_calib, can_specs=can_specs)",
    "crumbs": [
      "vcantest",
      "CCP over Scapy"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "candycan",
    "section": "",
    "text": "Features:\nItâ€™s based on Python-CAN, Scapy, cantools and dbc-editor",
    "crumbs": [
      "candycan"
    ]
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "candycan",
    "section": "Install",
    "text": "Install\nInstall all the dependencies listed in can-env.yaml and then install candycan\npip install candycan",
    "crumbs": [
      "candycan"
    ]
  },
  {
    "objectID": "index.html#data-link-layer-iso-11898-1",
    "href": "index.html#data-link-layer-iso-11898-1",
    "title": "candycan",
    "section": "Data link layer (ISO 11898-1)",
    "text": "Data link layer (ISO 11898-1)\n\nFrame sending and receiving\nconversion from Python dict object to json and CAN frame\nmessage parsing with given dbc\nMultiprocessing support for testing inside the notebook\nSecure CAN device add/remove with password proctected gpg encryption\nFlexible arguments setting with argparse and subprocess pipes\non native SocketCan or Python-CAN virtual CAN channel\nOptions with Python-CAN or Scapy backends\nintegrate can-utils, scapy sniff for large scale testing (tbd)\nextend to Kvaser, Vector, etc. (tbd)",
    "crumbs": [
      "candycan"
    ]
  },
  {
    "objectID": "index.html#ccp",
    "href": "index.html#ccp",
    "title": "candycan",
    "section": "CCP",
    "text": "CCP\n\non physical CAN device (Kvaser) with Scapy application interface\non physical CAN device with Python-CAN and CCP logic\ncontext manager for CCP functions\nCCP/XCP data codecs and data processing in Numpy array\nBytes codecs (raw binary, hex, numeric) with endianess handling\nFlexible arguments setting with argparse and interactive InquirerPy\nEncapsulation of CAN specs in unified Pydantic models (serialization, schema, validation, annotation, etc.)\nSelf incremental command counter inside CAN specs object\nType systems for CAN (native SocketCAN, Python-CAN) and bus (SocketCAN, virtual CAN, Kvaser, Vector, etc.)",
    "crumbs": [
      "candycan"
    ]
  },
  {
    "objectID": "index.html#a2l",
    "href": "index.html#a2l",
    "title": "candycan",
    "section": "A2L",
    "text": "A2L\n\na2l checking and fixing with pya2l and a2ltool\nconversion a2l file to legit json files\nal2 tree node, path and path segment definitions for positioning semantics\nsearching of calibration terms\nCalibration object with dynamic properties for easy access of class attributes\nCached properties for automatic data conversion and derivative properties like data size for corresponding data type\nException handling with missing calibration properties\nUnified processing of measurement, axis, conversion method and data layouts\nLazy loading and streaming json file processing with events based ijson\nEncapsulation of calibration properties and values in Pydantic objects (automatic validation, serialization, schemes, etc.)\nType systems for CCP/XCP data types\nXCPConfig for CCP/XCP configuration\nXCPData for encapsulating calibration data with automatic dimension, data size validation, automatic codecs of hex, raw and numeric values\narray view of table data as cached property with automatic type conversion and validation\nCreate calibration data object from a2l file\nGet calibration data from downloaded json file",
    "crumbs": [
      "candycan"
    ]
  },
  {
    "objectID": "index.html#dbc",
    "href": "index.html#dbc",
    "title": "candycan",
    "section": "DBC",
    "text": "DBC\n\nload dbc files with cantools\nappend new messages and signals to dbc files\nGUI for interactively modifying dbc on the command line with dbc-editor",
    "crumbs": [
      "candycan"
    ]
  },
  {
    "objectID": "index.html#xcp-tbd",
    "href": "index.html#xcp-tbd",
    "title": "candycan",
    "section": "XCP (tbd)",
    "text": "XCP (tbd)",
    "crumbs": [
      "candycan"
    ]
  },
  {
    "objectID": "02.ccp.virtual.html",
    "href": "02.ccp.virtual.html",
    "title": "CCP",
    "section": "",
    "text": "# #|export\n# from candycan.data_link_socketcan import done, send_msg",
    "crumbs": [
      "CCP"
    ]
  },
  {
    "objectID": "02.ccp.virtual.html#types-definition",
    "href": "02.ccp.virtual.html#types-definition",
    "title": "CCP",
    "section": "Types definition",
    "text": "Types definition\n\n\ncheck_can_type\n\n check_can_type (c:str)\n\n*Summary Check if the CAN type is valid\nArgs: can_type (str): CAN type to be checked\nReturns: str: CAN type if valid\nRaises: ValueError: if CAN type is invalid*\n\n# # CanType\n# native_can_type = CanType('NATIVE')\n# native_can_type.lower()\n# isinstance(native_can_type, CanType)\n# isinstance('NATIVE', CanType)\n\n\n\n\ncheck_bus_type\n\n check_bus_type (b:str)\n\n*Summary Check if the CAN bus type is valid\nArgs: b (str): Python CAN bus type to be checked\nReturns: str: Python CAN bus type if valid\nRaises: ValueError: if CAN bus type is invalid*\n\n\n\nCANFilter\n\n CANFilter (can_id:typing.Annotated[int,Gt(gt=0)]=630,\n            can_mask:typing.Annotated[int,Gt(gt=0)]=2047)\n\n*Summary CAN filter for Python CAN bus\nAttributes: can_id (int): CAN message ID can_mask (int): CAN message mask*\n\n\n\nScapyCANSpecs\n\n ScapyCANSpecs (can_type:typing.Annotated[str,AfterValidator(func=&lt;functio\n                ncheck_can_typeat0x7fc73e3f8ae0&gt;)]='NATIVE', bus_type:typi\n                ng.Annotated[str,AfterValidator(func=&lt;functioncheck_bus_ty\n                peat0x7fc73e3f8900&gt;)]='VIRTUAL', channel_serial_number:typ\n                ing.Annotated[int,Ge(ge=0),Lt(lt=500)]=3,\n                download_can_id:typing.Annotated[int,Gt(gt=0)]=630,\n                upload_can_id:typing.Annotated[int,Gt(gt=0)]=630,\n                can_filters:Optional[list[__main__.CANFilter]]=None, bit_r\n                ate:typing.Annotated[int,Gt(gt=0),Lt(lt=1000000)]=500000, \n                time_out:typing.Annotated[float,Gt(gt=0.0),Lt(lt=10.0)]=1.\n                0, station_address:typing.Annotated[int,Ge(ge=0),Lt(lt=255\n                )]=0,\n                cntr:typing.Annotated[int,Ge(ge=0),Lt(lt=1000000)]=0,\n                receive_own_messages:bool=True, download_upload:bool=True,\n                diff_mode:bool=False, diff_threshold:float=0.001,\n                last_download_data:Optional[candycan.a2l.XCPData]=None)\n\n*Usage docs: https://docs.pydantic.dev/2.7/concepts/models/\nA base class for creating Pydantic models.\nAttributes: class_vars: The names of classvars defined on the model. private_attributes: Metadata about the private attributes of the model. signature: The signature for instantiating the model.\n__pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n__pydantic_core_schema__: The pydantic-core schema used to build the SchemaValidator and SchemaSerializer.\n__pydantic_custom_init__: Whether the model has a custom `__init__` function.\n__pydantic_decorators__: Metadata containing the decorators defined on the model.\n    This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n__pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n    __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n__pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n__pydantic_post_init__: The name of the post-init method for the model, if defined.\n__pydantic_root_model__: Whether the model is a `RootModel`.\n__pydantic_serializer__: The pydantic-core SchemaSerializer used to dump instances of the model.\n__pydantic_validator__: The pydantic-core SchemaValidator used to validate instances of the model.\n\n__pydantic_extra__: An instance attribute with the values of extra fields from validation when\n    `model_config['extra'] == 'allow'`.\n__pydantic_fields_set__: An instance attribute with the names of fields explicitly set.\n__pydantic_private__: Instance attribute with the values of private attributes set on the model instance.*\n\ntry:\n    m = ScapyCANSpecs(can_type='NATIVE', bus_type='VIRTUAL')\nexcept ValidationError as exc:\n    print(exc)\n\npprint(m.model_dump())\n\n\ndef emulate_call(m: ScapyCANSpecs):\n    m.cntr += 1\n\nfor i in range(3):\n    emulate_call(m)\n    print(f\"{i}: counter {m.cntr}\")\n\n\nxcp_calib_from_xcpjson = Get_XCPCalib_From_XCPJSon(args.input)\nxcp_calib_from_xcpjson\n\n\nxcp_data = Generate_Init_XCPData_From_A2L(\n    a2l=args.a2l, keys=args.leaves, node_path=args.node_path\n)\n\n#  address from xcp data file should align with the address from xcp calib file\ntest_eq(xcp_data.address, xcp_calib_from_xcpjson.data[0].address)\n\n# validate the model\ntry:\n    XCPData.model_validate(xcp_data)\nexcept ValidationError as exc:\n    print(exc)\n\n\n# type(args.channel), type(args.download_id), args.upload_id, args.download, args.diff_flashing\n\n\nxcp_data.value = xcp_calib_from_xcpjson.data[0].value\npprint(xcp_data)\nxcp_data.value_array_view[0,2], xcp_data.value_array_view[2,0]\n\n\nxcp_calib = XCPCalib(\n    config=XCPConfig(\n        channel=args.channel_serial_number, download=args.download_can_id, upload=args.upload_can_id\n    ),\n    data=[xcp_data],\n)\n\n\npprint(xcp_calib)\n\n\nnpa =  xcp_calib.data[0].value_array_view\nnpa.shape, npa.dtype, npa\nlen(xcp_calib.data[0].value_bytes), xcp_calib.data[0].value_bytes\n\nlen(npa.tobytes()), npa.tobytes()\ntest_eq(npa.tobytes(), xcp_calib.data[0].value_bytes)\nxcp_calib.data[0].value\n\n\n# buffer = [i.hex() for x in npa for i in x]\n# # buffer[::-1]\n# len(buffer)\n# buffer\n\n\n# buffer = npa.tobytes()\n\n# pprint(buffer), len(buffer)\n# xcp_calib.data[0].value, len(xcp_calib.data[0].value)\n\n\naddr = bytes('7000aa2a', 'utf-8')\na = 0x7000aa2a\na\n\n\nnpb = npa[::-1]\n# npb\nbuffer = [struct.pack(\"&lt;f\", x) for x in np.nditer(npa)]\n# buffer\nlen(buffer)\n\n\n\ninvestigate int type and type size\n\nd = xcp_calib.data[0]\nadd = int(d.address, base=16)\nd.address, add\nhex(add), type(add), sys.getsizeof(add)\nstruct.calcsize('h'), struct.calcsize('i'), struct.calcsize('l'), struct.calcsize('L')\ntype(d.address),len(d.address)\n\n\n\n\nnpa_to_packed_buffer\n\n npa_to_packed_buffer (a:numpy.ndarray)\n\n*convert a numpy array to a packed string buffer for flashing TODO: implementation as numpy ufunc\nArgs: a (np.ndarray): input numpy array for flashing\nReturns: str: packed string buffer for flashing*\n\n# buffer = [struct.pack(\"&lt;f\", x).hex() for x in np.nditer(npa)]\n# buffer[::-1]\n# len(buffer)\n# buffer\n# data = ''.join(buffer)\ndata = npa_to_packed_buffer(npa)\ntest_eq(data, xcp_calib.data[0].value)\n# data",
    "crumbs": [
      "CCP"
    ]
  },
  {
    "objectID": "02.ccp.virtual.html#convert-a-numpy-array-to-a-continuous-hex-string",
    "href": "02.ccp.virtual.html#convert-a-numpy-array-to-a-continuous-hex-string",
    "title": "CCP",
    "section": "convert a numpy array to a continuous hex string",
    "text": "convert a numpy array to a continuous hex string\n\n# npa.astype(np.float32).tobytes().hex()\nbuffer = npa.astype(np.float32).tobytes().hex()  ## == npa_to_packed_buffer(npa)\nbuffer, len(buffer)\ntest_eq(buffer, xcp_calib.data[0].value)\n\n\n\nflash_xcp\n\n flash_xcp (xcp_calib:candycan.a2l.XCPCalib,\n            data:pandas.core.frame.DataFrame, diff_flashing:bool=False,\n            download:bool=True)\n\n*Summary Flash XCP data to target\nArgs: xcp_calib (XCPCalib): XCP calibration as template, contains all the meta information except for data xcp_data (pd.DataFrame): input XCP data to be flashed, replace the value in xcp_calib diff_flashing (bool): Use differential flashing download (bool): Download or upload*\n\npkt = IP()\npkt.canvas_dump()\n\n\nIP()\na = IP(dst=\"10.10.10.28\")\na.dst\na.ttl\nls(IP)\n\n\nos.getcwd()\na = rdpcap('../res/pcaps/ipfix.pcap')\na\n# a[0].pdfdump(layer_shift=1)\na[1].psdump(\"/tmp/ipfix.eps\", layer_shift=1)",
    "crumbs": [
      "CCP"
    ]
  },
  {
    "objectID": "02.ccp.virtual.html#cro-for-connection",
    "href": "02.ccp.virtual.html#cro-for-connection",
    "title": "CCP",
    "section": "CRO for connection",
    "text": "CRO for connection\n\nxcp_calib.config.download_can_id\nhex(xcp_calib.config.download_can_id)\n\n\nchannel = 'can' + str(xcp_calib.config.channel)\nchannel\n\n\nctr = 0\nprint(f\"ctr: {ctr}\")\ncro = CCP(identifier=xcp_calib.config.download_can_id)/CRO(ctr=ctr)/CONNECT()  # CONNECT(station_address=0x02)?\ncro.show2()\ncro.canvas_dump()\n\n\nsocket.send(cro)\nctr += 1\nrx_cro = socket.recv()\nrx_cro.show2()\nrx_cro.canvas_dump()\n# dto = sock.sr1(cro)\n# dto.show2()\n# assert dto.return_code == 0x00",
    "crumbs": [
      "CCP"
    ]
  },
  {
    "objectID": "02.ccp.virtual.html#download-from-target",
    "href": "02.ccp.virtual.html#download-from-target",
    "title": "CCP",
    "section": "Download from target",
    "text": "Download from target\n\nxcp_calib.data\n\n\nd = xcp_calib.data[0]\nd.address, d.type_size, d.dim, d.value_array_view, d.value_bytes\nlen(d.value_bytes )\nd.value",
    "crumbs": [
      "CCP"
    ]
  },
  {
    "objectID": "02.ccp.virtual.html#set-mta",
    "href": "02.ccp.virtual.html#set-mta",
    "title": "CCP",
    "section": "set mta",
    "text": "set mta\n\nprint(f\"ctr: {ctr}\")\ncro = CCP(identifier=xcp_calib.config.download_can_id)/CRO(ctr=ctr)/SET_MTA(address=int(d.address, 16))\ncro.show2()\ncro.payload\nsocket.send(cro)\nctr += 1\nrx_cro = socket.recv()\nrx_cro.show2()\n# dto = sock.sr1(cro)\n# dto.show2()\n# assert dto.return_code == 0x00\nrx_cro.canvas_dump()\n\n\nlen_in_bytes = d.type_size * d.dim[0] * d.dim[1]\nprint(f\"len_in_bytes: {len_in_bytes} = type_size: {d.type_size} x dim: {d.dim}\")\n\ndownload_times = len_in_bytes // 6\nlast_download_size = len_in_bytes % 6\nprint(f\"download_times: {download_times}, last_download_size: {last_download_size}\")\n\n\nd.value_bytes\nlen(d.value_bytes)\ntile0 = d.value_bytes[0:6]\nlen(tile0), tile0, tile0.hex(), type(tile0)\ntile1 = d.value_bytes[6:12]\nlen(tile1), tile1, tile1.hex()\n\n\ntile0 = d.value_bytes[0:4]\nlen(tile0), tile0, tile0.hex(), type(tile0), struct.unpack(\"&lt;f\", tile0)\ntile1 = d.value_bytes[4:8]\nlen(tile1), tile1, tile1.hex(), struct.unpack(\"&lt;f\", tile1)\ntile2 = d.value_bytes[8:12]\nlen(tile1), tile2, tile2.hex(), struct.unpack(\"&lt;f\", tile2)\nst = 2*17*4\ntile3 = d.value_bytes[st:st+4]\nlen(tile1), tile3, tile3.hex(), struct.unpack(\"&lt;f\", tile3)\nd.value_array_view[2,0]\ntest_eq(struct.unpack(\"&lt;f\", tile3), d.value_array_view[2,0])\n\n\ntile3.hex(), tile3.hex().encode()\n\n\ntype(tile3)\nlist(tile3)\n\n\nba_uploaded = bytearray()\nba_uploaded += tile3\nba_uploaded\nba_uploaded += tile2\nba_uploaded += tile1\nba_uploaded, len(ba_uploaded)\n\n\nba_uploaded = bytearray()\nlen_in_bytes = d.type_size * d.dim[0] * d.dim[1]\ndownload_times = len_in_bytes // 6\nlast_download_size = len_in_bytes % 6\nfor tile in range(download_times):\n    ba_uploaded += d.value_bytes[tile*6:(tile+1)*6]\nif last_download_size:\n    ba_uploaded += d.value_bytes[download_times*6:download_times*6+last_download_size]\n\nlen(ba_uploaded), ba_uploaded.hex()\ntest_eq(ba_uploaded, d.value_bytes)\ntest_eq(ba_uploaded.hex(), d.value)\nba_uploaded.hex()",
    "crumbs": [
      "CCP"
    ]
  },
  {
    "objectID": "02.ccp.virtual.html#loop-over-xcpcalib-data-array",
    "href": "02.ccp.virtual.html#loop-over-xcpcalib-data-array",
    "title": "CCP",
    "section": "loop over XCPCalib data array",
    "text": "loop over XCPCalib data array\n\nfor i in range(download_times):\n    cro = CCP(identifier=xcp_calib.config.download_can_id)/CRO(ctr=ctr)/DNLOAD_6(data=d.value_bytes[i*6:(i+1)*6])\n    if i%100==0:\n        print(f\"i: {i},  ctr: {ctr}, cro: {cro}\")\n        cro.show2()\n        cro.payload\n    sent_bytes = socket.send(cro)\n    ctr += 1\n    rx_cro = socket.recv()\n    # rx_cro.show2()\n    # dto = sock.sr1(cro)\n    # dto.show2()\n    # assert dto.return_code == 0x00\ni\ncro.canvas_dump()\nrx_cro.canvas_dump()\n\n\nstart_index = download_times * 6\ncro = CCP(identifier=xcp_calib.config.download_can_id)/CRO(ctr=ctr)/DNLOAD(data=d.value_bytes[start_index:start_index+last_download_size])\nprint(f\"ctr: {ctr}\")\ncro.show2()\ncro.payload\ncro.canvas_dump()\nsent_bytes = socket.send(cro)\nctr += 1 \nrx_cro = socket.recv()\nrx_cro.canvas_dump()",
    "crumbs": [
      "CCP"
    ]
  },
  {
    "objectID": "02.ccp.virtual.html#disconnect-target-ecu",
    "href": "02.ccp.virtual.html#disconnect-target-ecu",
    "title": "CCP",
    "section": "Disconnect target ecu",
    "text": "Disconnect target ecu\n\ncro = CCP(identifier=xcp_calib.config.download_can_id)/CRO(ctr=ctr)/DISCONNECT(station_address=0x00)\nprint(f\"ctr: {ctr}\")\ncro.show2()\ncro.canvas_dump()\nbytes_sent = socket.send(cro)\nctr += 1\ncx_cro = socket.recv()\ncx_cro.show2()\ncx_cro.canvas_dump()",
    "crumbs": [
      "CCP"
    ]
  },
  {
    "objectID": "02.ccp.virtual.html#download_calib_data",
    "href": "02.ccp.virtual.html#download_calib_data",
    "title": "CCP",
    "section": "download_calib_data",
    "text": "download_calib_data\n\n\ndownlod_calib_data\n\n downlod_calib_data (xcp_calib:candycan.a2l.XCPCalib, can_type:typing.Anno\n                     tated[str,AfterValidator(func=&lt;functioncheck_can_type\n                     at0x7fc73e3f8ae0&gt;)], channel:int, bus_type:typing.Ann\n                     otated[str,AfterValidator(func=&lt;functioncheck_bus_typ\n                     eat0x7fc73e3f8900&gt;)], can_filter=list[dict],\n                     bit_rate:int=500000, timeout:float=1.0,\n                     diff_flashing:bool=False)\n\n*Summary Download XCP calibration data to target\nArgs: xcp_calib (XCPCalib): XCP calibration to be downloaded into the target diff_flashing (bool): Use differential flashing*",
    "crumbs": [
      "CCP"
    ]
  },
  {
    "objectID": "02.ccp.virtual.html#upload_calib_data",
    "href": "02.ccp.virtual.html#upload_calib_data",
    "title": "CCP",
    "section": "upload_calib_data",
    "text": "upload_calib_data\n\n\nupload_calib_data\n\n upload_calib_data (xcp_calib:candycan.a2l.XCPCalib, can_type:typing.Annot\n                    ated[str,AfterValidator(func=&lt;functioncheck_can_typeat\n                    0x7fc73e3f8ae0&gt;)], channel:int, bus_type:typing.Annota\n                    ted[str,AfterValidator(func=&lt;functioncheck_bus_typeat0\n                    x7fc73e3f8900&gt;)], can_filter=list[dict],\n                    bit_rate:int=500000, timeout:float=1.0,\n                    diff_flashing:bool=False)\n\n*Summary Upload XCP calibration data from target to host, the result will update the xcp_calib.data field\nArgs: xcp_calib (XCPCalib): XCP calibration to be uploaded from the target to host diff_flashing (bool): Use differential flashing*",
    "crumbs": [
      "CCP"
    ]
  },
  {
    "objectID": "02.ccp.virtual.html#three-context-managers-for-ccp",
    "href": "02.ccp.virtual.html#three-context-managers-for-ccp",
    "title": "CCP",
    "section": "Three context managers for CCP",
    "text": "Three context managers for CCP\n\n\ncan_context\n\n can_context (can_specs:__main__.ScapyCANSpecs)\n\n*Summary Context manager for scapy CAN socket\nArgs: can_specs (ScapyCANSpecs): CAN specs including can type, bus type, channel, etc.\nYields: CANSocket: CAN socket object*\n\n\n\nSET_MTA_context\n\n SET_MTA_context (can_specs:__main__.ScapyCANSpecs,\n                  sock:scapy.contrib.cansocket_native.NativeCANSocket,\n                  data:candycan.a2l.XCPData)\n\n*Summary Context manager for scapy set_mta\nArgs: channel (str): CAN channel to use, default is vcan0\nYields: CAN: packdet for CAN message*\n\n\n\nXLOAD_context\n\n XLOAD_context (can_specs:__main__.ScapyCANSpecs,\n                sock:scapy.contrib.cansocket_native.NativeCANSocket,\n                data:candycan.a2l.XCPData, start_index:int, tile_size:int)\n\n*Summary Context manager for scapy load (download or upload)\nArgs: channel (str): CAN channel to use, default is vcan0\nYields: CANSocket: CAN socket object*\n\ncan_filters = [{'can_id': xcp_calib.config.upload_can_id, 'can_mask': 0x7FF}]\ncan_specs = ScapyCANSpecs(can_type='NATIVE', \n                        bus_type='VIRTUAL', \n                        channel_serial_number=0,\n                        download_can_id=xcp_calib.config.download_can_id,\n                        upload_can_id=xcp_calib.config.upload_can_id,\n                        can_filters=can_filters,\n                        bit_rate=500_000,\n                        time_out=1.0,\n                        station_address=0x00,\n                        cntr=0,\n                        receive_own_messages=True,\n                        download_upload=True\n                        )\ncan_specs\ncan_specs.model_dump()",
    "crumbs": [
      "CCP"
    ]
  },
  {
    "objectID": "02.ccp.virtual.html#downloading-and-uploading-with-context-managers",
    "href": "02.ccp.virtual.html#downloading-and-uploading-with-context-managers",
    "title": "CCP",
    "section": "Downloading and uploading with context managers",
    "text": "Downloading and uploading with context managers\n\n\nupload_calib_data2\n\n upload_calib_data2 (xcp_calib:candycan.a2l.XCPCalib,\n                     can_specs:__main__.ScapyCANSpecs)\n\n*Summary Upload XCP calibration data from target to host, the result will update the xcp_calib.data field\nArgs: xcp_calib (XCPCalib): XCP calibration to be uploaded from the target to host diff_flashing (bool): Use differential flashing*\n\n\n\ndownlod_calib_data2\n\n downlod_calib_data2 (xcp_calib:candycan.a2l.XCPCalib,\n                      can_specs:__main__.ScapyCANSpecs)\n\n*Summary Download XCP calibration data to target use scapy_can_context\nArgs: xcp_calib (XCPCalib): XCP calibration to be downloaded into the target*\n\nxcp_calib.config.channel = 0\nxcp_calib\n\n\n# TODO cannot run test on CCP without a real or emulated ECU \n# downlod_calib_data2(xcp_calib, can_type='NATIVE', bus_type='VIRTUAL', bit_rate=500_000, timeout=1.0, station_address=0x00, diff_flashing=False)",
    "crumbs": [
      "CCP"
    ]
  },
  {
    "objectID": "06.dbc.html",
    "href": "06.dbc.html",
    "title": "dbc",
    "section": "",
    "text": "db = cantools.database.load_file('../res/motohawk_new.dbc')\ndb.messages\nexample_message: MessageTpl = db.get_message_by_name('ExampleMessage')\npprint(example_message.signals)\npprint(example_message.__dict__)\nexample_message.frame_id\n\n\nFollowing show how to create a new dbc file from scratch using cantools\n\ncan_id = example_message.frame_id + 10\ncan_id\n\n\ncan_db = cantools.db\ndb_new = cantools.database.Database(version='0.1')\nsig = can_db.Signal(name=\"torque_table\", \n                    start=0, \n                    length=8, \n                    byte_order='big_endian', \n                    is_signed=False, \n                    minimum=0, \n                    maximum=255, \n                    unit='Nm',\n                    comment=\"self made signal\",\n                    is_multiplexer=False)\n\nmsg = can_db.Message(frame_id=can_id,\n                    name=\"NewMessage\",\n                    signals=[sig],\n                    length=8,\n                    is_extended_frame=False,\n                    is_fd=False,\n                    comment=\"self made message\",\n                    send_type=0,\n                    cycle_time=0,\n                    bus_name=\"PT\",\n                    )\n\ndb_new.messages.append(msg)\n# can_db.add_message(msg)\ncantools.database.dump_file(database=db_new,filename='test.dbc')\n# db.dump('test.dbc')\n\n\n\nFollowing show how to append a new message to an existing dbc using cantools\n\ncan_id = example_message.frame_id + 200\ncan_db = cantools.db\ndb.version = '1.1'\nsig = can_db.Signal(name=\"eco_table\", \n                    start=0, \n                    length=8, \n                    byte_order='big_endian', \n                    is_signed=False, \n                    minimum=0, \n                    maximum=255, \n                    unit='Nm',\n                    comment=\"self made signal\",\n                    is_multiplexer=False)\n\nmsg = can_db.Message(frame_id=can_id,\n                    name=\"AppendedMessage\",\n                    signals=[sig],\n                    length=8,\n                    is_extended_frame=False,\n                    is_fd=False,\n                    comment=\"self made message\",\n                    send_type=0,\n                    cycle_time=0,\n                    bus_name=\"PT\",\n                    )\n\ndb.messages.append(msg)\n# can_db.add_message(msg)\ncantools.database.dump_file(database=db,filename='../res/motohawk_appended.dbc')\n# db.dump('test.dbc')",
    "crumbs": [
      "dbc"
    ]
  },
  {
    "objectID": "05.data_link.scapycan.html",
    "href": "05.data_link.scapycan.html",
    "title": "data link layer with scapy wrapper",
    "section": "",
    "text": "get_argparser\n\n get_argparser ()\n\n*summary get CAN bus, dbc config and the message to send\nReturns: argparse.ArgumentParser: description*\n\n\n\nsignal_usr1\n\n signal_usr1 (signum, frame)\n\nHandle USR1 signal as an event to set the received flag.\n\n\n\nsend_msg\n\n send_msg (db:cantools.database.can.database.Database, message:str,\n           payload:bytes, channel:str, bitrate:int, bus_type:str,\n           can_filters:list[dict], is_extended:bool)\n\n*send a message to the CAN bus\nreturn the bytes sent to the bus (default 16 bytes for a struct of CAN frame, payload 8 bytes)*\n\ndb_can = cantools.database.load_file(repo.working_dir+'/res/motohawk_new.dbc')\ndb_can.messages\n\n[message('ExampleMessage', 0x1f0, False, 8, {None: 'Example message used as template in MotoHawk models.'}),\n message('NewMessage', 0x254, False, 8, {None: 'self made message'})]\n\n\n\nexample_message: MessageTpl = db_can.get_message_by_name('ExampleMessage')\npprint(example_message.signals)\npprint(example_message.__dict__)\nexample_message.frame_id\n\n[signal('Enable', 7, 1, 'big_endian', False, None, 1, 0, None, None, '-', False, None, {0: 'Disabled', 1: 'Enabled'}, None, None),\n signal('AverageRadius', 6, 6, 'big_endian', False, None, 0.1, 0, 0, 5, 'm', False, None, None, None, None),\n signal('Temperature', 0, 12, 'big_endian', True, None, 0.01, 250, 229.52, 270.47, 'degK', False, None, None, None, None)]\n{'_autosar': None,\n '_bus_name': None,\n '_codecs': {'formats': Formats(big_endian=&lt;bitstruct.c.CompiledFormatDict object&gt;, little_endian=&lt;bitstruct.c.CompiledFormatDict object&gt;, padding_mask=35184372088831),\n             'multiplexers': {},\n             'signals': [signal('Enable', 7, 1, 'big_endian', False, None, 1, 0, None, None, '-', False, None, {0: 'Disabled', 1: 'Enabled'}, None, None),\n                         signal('AverageRadius', 6, 6, 'big_endian', False, None, 0.1, 0, 0, 5, 'm', False, None, None, None, None),\n                         signal('Temperature', 0, 12, 'big_endian', True, None, 0.01, 250, 229.52, 270.47, 'degK', False, None, None, None, None)]},\n '_comments': {None: 'Example message used as template in MotoHawk models.'},\n '_contained_messages': None,\n '_cycle_time': None,\n '_dbc': &lt;cantools.database.can.formats.dbc_specifics.DbcSpecifics object&gt;,\n '_frame_id': 496,\n '_header_byte_order': 'big_endian',\n '_header_id': None,\n '_is_extended_frame': False,\n '_is_fd': False,\n '_length': 8,\n '_name': 'ExampleMessage',\n '_protocol': None,\n '_send_type': None,\n '_senders': ['PCM1'],\n '_signal_dict': {'AverageRadius': signal('AverageRadius', 6, 6, 'big_endian', False, None, 0.1, 0, 0, 5, 'm', False, None, None, None, None),\n                  'Enable': signal('Enable', 7, 1, 'big_endian', False, None, 1, 0, None, None, '-', False, None, {0: 'Disabled', 1: 'Enabled'}, None, None),\n                  'Temperature': signal('Temperature', 0, 12, 'big_endian', True, None, 0.01, 250, 229.52, 270.47, 'degK', False, None, None, None, None)},\n '_signal_groups': [],\n '_signal_tree': ['Enable', 'AverageRadius', 'Temperature'],\n '_signals': [signal('Enable', 7, 1, 'big_endian', False, None, 1, 0, None, None, '-', False, None, {0: 'Disabled', 1: 'Enabled'}, None, None),\n              signal('AverageRadius', 6, 6, 'big_endian', False, None, 0.1, 0, 0, 5, 'm', False, None, None, None, None),\n              signal('Temperature', 0, 12, 'big_endian', True, None, 0.01, 250, 229.52, 270.47, 'degK', False, None, None, None, None)],\n '_strict': True,\n '_unused_bit_pattern': 255}\n\n\n496\n\n\n\nif blue_pill:\n    # install vcan interface with encrypted password to sudo \n    os.system(\"gpg -d -q ~/.sshpasswd.gpg | sshpass -v sudo modprobe vcan\")\n    # sshpass -v -p asdf sudo ip link add dev vcan0 type vcan\n    os.system(\"gpg -d -q ~/.sshpasswd.gpg | sshpass -v sudo ip link add dev vcan0 type vcan\")\n    # !gpg -d -q ~/.sshpasswd.gpg | sshpass -v sudo ip link set vcan0 type vcan bitrate 500000  # vcan does not support set bitrate on command line!\n    # !sshpass -p asdf sudo ip link add dev vcan0 type vcan\n    os.system(\"gpg -d -q ~/.sshpasswd.gpg | sshpass -v sudo ip link set up vcan0\")\n    # !sshpass -v -p asdf sudo ip link set up vcan0\nelse:\n    os.system(\"sudo modprobe vcan\")\n    os.system(\"sudo ip link add dev vcan0 type vcan\")\n    os.system(\"sudo ip link set up vcan0\")\n\nos.system(\"ip link show vcan0\")\n\nSSHPASS: searching for password prompt using match \"assword\"\nSSHPASS: read: [sudo] password for n: \nSSHPASS: detected prompt. Sending password.\nSSHPASS: read: \n\nSSHPASS: searching for password prompt using match \"assword\"\nSSHPASS: read: [sudo] password for n: \nSSHPASS: detected prompt. Sending password.\nSSHPASS: read: \n\nSSHPASS: searching for password prompt using match \"assword\"\nSSHPASS: read: [sudo] password for n: \nSSHPASS: detected prompt. Sending password.\nSSHPASS: read: \n\n\n\n0\n\n\n0\n\n\n0\n\n\n72: vcan0: &lt;NOARP,UP,LOWER_UP&gt; mtu 72 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000\n    link/can \n\n\n0\n\n\n\n# # install vcan interface with encrypted password to sudo \n# !gpg -d -q ~/.sshpasswd.gpg | sshpass -v sudo modprobe vcan\n# # sshpass -v -p asdf sudo ip link add dev vcan0 type vcan\n# !gpg -d -q ~/.sshpasswd.gpg | sshpass -v sudo ip link add dev vcan0 type vcan\n# !ip link show vcan0\n# # !gpg -d -q ~/.sshpasswd.gpg | sshpass -v sudo ip link set vcan0 type vcan bitrate 500000  # vcan does not support set bitrate on command line!\n# # !sshpass -p asdf sudo ip link add dev vcan0 type vcan\n# !gpg -d -q ~/.sshpasswd.gpg | sshpass -v sudo ip link set up vcan0\n# # !sshpass -v -p asdf sudo ip link set up vcan0\n\n\ndata_dict ={'Temperature': 250.1, 'AverageRadius': 3.2, 'Enable': 1}\ndata_json_bytes = json.dumps(data_dict).encode('utf-8')\ndata_json_bytes\njson.loads(data_json_bytes.decode())\n\ncan_data = example_message.encode({'Temperature': 250.1, 'AverageRadius': 3.2, 'Enable': 1})\nexample_message.decode(can_data)\ncan_data\n\nb'{\"Temperature\": 250.1, \"AverageRadius\": 3.2, \"Enable\": 1}'\n\n\n{'Temperature': 250.1, 'AverageRadius': 3.2, 'Enable': 1}\n\n\n{'Enable': 'Enabled', 'AverageRadius': 3.2, 'Temperature': 250.1}\n\n\nb'\\xc0\\x01@\\x00\\x00\\x00\\x00\\x00'\n\n\n\n#create can frame\npacket = CAN(identifier=example_message.frame_id, data=can_data)\npacket.show2()\n\n###[ CAN ]### \n  flags     = \n  identifier= 0x1f0\n  length    = 8\n  reserved  = 0\n  data      = '\\\\xc0\\x01@\\x00\\x00\\x00\\x00\\x00'\n\n\n\n\n# create socket\nsocket = CANSocket(bustype='socketcan', \n                channel='vcan0', \n                can_filters=None, \n                bitrate=25000, \n                is_extended=False)\nsocket\n# bus = can.interface.Bus(bustype='socketcan', channel='vcan0', bitrate=250000)\n# message_to_send = can.Message(arbitration_id=example_message.frame_id, data=can_data, is_extended_id=False)   \n# # can_bus.send(message)\n\n&lt;&lt;NativeCANSocket: read/write packets at a given CAN interface using PF_CAN sockets&gt;&gt;\n\n\n\nproc = subprocess.Popen(\n    ['python', \n        repo.working_dir+'/candycan/data_link/scapycan.py', \n        '-t', 'socketcan', \n        '-c' , 'vcan0', \n        '-b', '25000',\n        '-d', repo.working_dir+'/res/motohawk_new.dbc',\n        '-m', 'ExampleMessage',\n        ], \n    stdout=subprocess.PIPE, \n    stderr=subprocess.PIPE, \n    stdin=subprocess.PIPE\n    )\nprint(f'PARENT: {proc.pid} before signaling child')\n\nPARENT: 1085978 before signaling child\n\n\n\ndata_json_bytes\ndata_json_bytes.decode()\njson.loads(data_json_bytes.decode())\n\nb'{\"Temperature\": 250.1, \"AverageRadius\": 3.2, \"Enable\": 1}'\n\n\n'{\"Temperature\": 250.1, \"AverageRadius\": 3.2, \"Enable\": 1}'\n\n\n{'Temperature': 250.1, 'AverageRadius': 3.2, 'Enable': 1}\n\n\n\ntry:\n    outs, errs = proc.communicate(data_json_bytes, timeout=1)\nexcept subprocess.TimeoutExpired:\n    print(f'PARENT: {proc.pid}; TimeoutExpired')\n    # outs, errs = proc.communicate()\n    # print(f'PARENT: {proc.pid}; outs: {outs}; errs: {errs} TimeoutExpired')\n# sys.stdout.flush()\n# time.sleep(1)\n\nPARENT: 1085978; TimeoutExpired\n\n\n\nrx_packet = socket.recv()\nrx_packet.show2()\n# receive_message(message_proxy, bus)\n# proc_receive = subprocess.Popen(\n#   ['python', \n#         '../candycan/receive_message.py', \n#       '-t', 'socketcan', \n#       '-c' , 'vcan0', \n#       '-b', '25000',\n#       '-d', '../res/motohawk_new.dbc',\n#       '-m', 'ExampleMessage',\n#       ], \n#   # stdout=subprocess.PIPE, \n#   # stderr=subprocess.PIPE, \n#   # stdin=subprocess.PIPE\n#   )\n# print(f'PARENT: {proc.pid} before signaling child')\n\n# stdout_raw, stderr_raw = proc_receive.communicate()\n# stdout_value = stdout_raw.decode('utf-8')\n# stderr_value = stderr_raw.decode('utf-8')\n# # [0].decode('utf-8')\n# stdout_value\n# stderr_value\n\n###[ CAN ]### \n  flags     = \n  identifier= 0x1f0\n  length    = 8\n  reserved  = 0\n  data      = '\\\\xc0\\x01@\\x00\\x00\\x00\\x00\\x00'\n\n\n\n\nprint(f'PARENT: {proc.pid} signaling child')\n# sys.stdout.flush()\nos.kill(proc.pid, signal.SIGUSR1)\n\nPARENT: 1085978 signaling child\n\n\n\nstdout_raw, stderr_raw = proc.communicate()\nstdout_value = stdout_raw.decode('utf-8')\nstderr_value = stderr_raw.decode('utf-8')\n\nprint(f'stdout: {repr(stdout_value)}; stderr: {repr(stderr_value)}')\n# [0].decode('utf-8')\n\nstdout: \"'/home/n/devel/candycan'\\nsent bytes: 16\\nSignal received after 0.568 seconds\\n\"; stderr: ''\n\n\n\nhexdump(rx_packet)\nhexdump(packet)\n\n0000  00 00 01 F0 08 00 00 00 C0 01 40 00 00 00 00 00  ..........@.....\n0000  00 00 01 F0 08 00 00 00 C0 01 40 00 00 00 00 00  ..........@.....\n\n\n\n# datetime.fromtimestamp(message_proxy['timestamp']),db_can.decode_message(message_proxy['arbitration_id'],message_proxy['data'])\ndatetime.fromtimestamp(rx_packet.time), db_can.decode_message(rx_packet.identifier, rx_packet.data)\n\n(datetime.datetime(2024, 4, 11, 15, 58, 21, 374909),\n {'Enable': 'Enabled', 'AverageRadius': 3.2, 'Temperature': 250.1})\n\n\n\n\ncreate native CANSocket with loopback\n\nif blue_pill:\n    # install vcan1 interface with encrypted password to sudo \n    # sshpass -v -p asdf sudo ip link add dev vcan0 type vcan\n    os.system(\"gpg -d -q ~/.sshpasswd.gpg | sshpass -v sudo ip link add dev vcan1 type vcan\")\n    os.system(\"gpg -d -q ~/.sshpasswd.gpg | sshpass -v sudo ip link set up vcan1\")\nelse:\n    os.system(\"sudo ip link add dev vcan1 type vcan\")\n    os.system(\"sudo ip link set up vcan1\")\n\nos.system(\"ip link show vcan1\")\n\nSSHPASS: searching for password prompt using match \"assword\"\nSSHPASS: read: [sudo] password for n: \nSSHPASS: detected prompt. Sending password.\nSSHPASS: read: \n\nRTNETLINK answers: File exists\nSSHPASS: searching for password prompt using match \"assword\"\nSSHPASS: read: [sudo] password for n: \nSSHPASS: detected prompt. Sending password.\nSSHPASS: read: \n\n\n\n512\n\n\n0\n\n\n10: vcan1: &lt;NOARP,UP,LOWER_UP&gt; mtu 72 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000\n    link/can \n\n\n0\n\n\n\n# create socket\nsocket1 = CANSocket(bustype='socketcan', \n                channel='vcan1', \n                receive_own_messages=True,\n                can_filters=None, \n                bitrate=25000, \n                is_extended=False)\nsocket1\n\n&lt;&lt;NativeCANSocket: read/write packets at a given CAN interface using PF_CAN sockets&gt;&gt;\n\n\n\npacket.show2()\n\n###[ CAN ]### \n  flags     = \n  identifier= 0x1f0\n  length    = 8\n  reserved  = 0\n  data      = '\\\\xc0\\x01@\\x00\\x00\\x00\\x00\\x00'\n\n\n\n\nsent_bytes = socket1.send(packet)\nsent_bytes\n\n16\n\n\n\nrx_packet1 = socket1.recv()\nrx_packet1.show2()\n\n###[ CAN ]### \n  flags     = \n  identifier= 0x1f0\n  length    = 8\n  reserved  = 0\n  data      = '\\\\xc0\\x01@\\x00\\x00\\x00\\x00\\x00'\n\n\n\n\nif blue_pill:\n    # close and remove vcan0\n    # !sshpass -v -p  asdf sudo ip link delete vcan0 \n    os.system(\"gpg -d -q ~/.sshpasswd.gpg | sshpass -v sudo ip link set down vcan0\")\n    # delete vcan0\n    os.system(\"gpg -d -q ~/.sshpasswd.gpg | sshpass -v sudo ip link delete vcan0\")\nelse:\n    os.system(\"sudo ip link set down vcan0\")\n    os.system(\"sudo ip link delete vcan0\")\n\nSSHPASS: searching for password prompt using match \"assword\"\nSSHPASS: read: [sudo] password for n: \nSSHPASS: detected prompt. Sending password.\nSSHPASS: read: \n\nSSHPASS: searching for password prompt using match \"assword\"\nSSHPASS: read: [sudo] password for n: \nSSHPASS: detected prompt. Sending password.\nSSHPASS: read: \n\n\n\n0\n\n\n0",
    "crumbs": [
      "data link layer with scapy wrapper"
    ]
  },
  {
    "objectID": "01.a2l.html",
    "href": "01.a2l.html",
    "title": "A2L",
    "section": "",
    "text": "list_of_strings\n\n list_of_strings (strings:str)\n\n*split a string separated by â€˜,â€™, â€˜;â€™, or â€˜â€™ to a list of strings. Descripttion: split a long string to a list of strings.\nArgs: strings (str): The string to split.\nReturns: list: The list of strings.*\n\ntest_eq(list_of_strings(r'foo;123, bar ebi'), ['foo','123','bar','ebi'])\nlist_of_strings(r'\"/PROJECT/MODULE[0]/MOD_COMMON, /PROJECT/IF_DATA[0]/Blob[0]/, /PROJECT/MODULE[0]/CHARACTERISTIC, TQD_trqTrqSetNormal_MAP_v\"')\n\n['\"/PROJECT/MODULE[0]/MOD_COMMON',\n '/PROJECT/IF_DATA[0]/Blob[0]/',\n '/PROJECT/MODULE[0]/CHARACTERISTIC',\n 'TQD_trqTrqSetNormal_MAP_v\"']\n\n\n\n\n\nJsonNodePathSegment\n\n JsonNodePathSegment (name:str, indices:list[int]=None,\n                      index_range:list[int]=None)\n\n*result of parsing json node path segment\nArgs: name (str): name of the node indices (list[int]): indices of the node index_range (list[int]): index range of the node\n    if both indices and index_range are None, then the node is a dict, otherwise it is a list*\n\n\n\nJsonNodePath\n\n JsonNodePath (node_path:str)\n\n*result of parsing json node path\nArgs: segments (listJsonNodePathSegment): list of JsonNodePathSegment*\n\nnode_path = r\"/PROJECT[0]/MODULE[0,3,5]/IF_DATA[3:2:8]/CHARACTERISTIC[3:5]/TQD_trqTrqSetNormal_MAP_v\"\njnode_path = JsonNodePath(node_path)\nprint(jnode_path)\nres = ['&lt;PROJECT[0] list&gt;', '&lt;MODULE[0,3,5] list&gt;', '&lt;IF_DATA[3:2:8] list&gt;', '&lt;CHARACTERISTIC[3:5] list&gt;', '&lt;TQD_trqTrqSetNormal_MAP_v dict&gt;'] \nfor (s,r) in zip(jnode_path,res):\n    print(s)\n    test_eq(s.__str__(), r)\n\n&lt;JsonNodePath [&lt;PROJECT[0] list&gt;, &lt;MODULE[0,3,5] list&gt;, &lt;IF_DATA[3:2:8] list&gt;, &lt;CHARACTERISTIC[3:5] list&gt;, &lt;TQD_trqTrqSetNormal_MAP_v dict&gt;]&gt;\n&lt;PROJECT[0] list&gt;\n&lt;MODULE[0,3,5] list&gt;\n&lt;IF_DATA[3:2:8] list&gt;\n&lt;CHARACTERISTIC[3:5] list&gt;\n&lt;TQD_trqTrqSetNormal_MAP_v dict&gt;\n\n\n\n\n\nget_argparser\n\n get_argparser ()\n\n*Get the argument parser for the command line interface. Descripttion: Get the argument parser for the command line interface.\nReturns: argparse.ArgumentParser: The argument parser for the command line interface.*\n\n# jnode_paths = []\n# for p in args.node_paths:\n#   print(p)\n#   jnode_path = JsonNodePath(p)\n#   print(jnode_path)\n#   jnode_paths.append(jnode_path)\n#   pprint(jnode_path.lazy_path)\n#   pprint(re.split(r'\\.', jnode_path.lazy_path)) \n#   pprint(jnode_path.leaf.name)\n#   print()\nprint(args.node_path)\njnode_path = JsonNodePath(args.node_path)\nprint(jnode_path)\npprint(jnode_path.lazy_path)\npprint(re.split(r'\\.', jnode_path.lazy_path)) \npprint(jnode_path.leaf.name)\nprint()\n# node_path = r\"/PROJECT/MODULE[]/CHARACTERISTIC[]\"\n# node_path = args.node_path\n# jnode_path = JsonNodePath(node_path)\n# res = ['&lt;PROJECT[0] list&gt;', '&lt;MODULE[0,3,5] list&gt;', '&lt;IF_DATA[3:2:8] list&gt;', '&lt;CHARACTERISTIC[3:5] list&gt;', '&lt;TQD_trqTrqSetNormal_MAP_v dict&gt;'] \nfor s in jnode_path:\n    print(s)\n\n/PROJECT/MODULE[], \n&lt;JsonNodePath [&lt;PROJECT dict&gt;, &lt;MODULE[] list&gt;]&gt;\n'PROJECT.MODULE.item'\n['PROJECT', 'MODULE', 'item']\n'MODULE'\n\n&lt;PROJECT dict&gt;\n&lt;MODULE[] list&gt;\n\n\n\nnode_path = r\"/PROJECT/MODULE[]/CHARACTERISTIC[]\"\nre.split(r',\\s*|;\\s*|/\\s*|\\s+', node_path)  \nre.split('(?:\\[\\d\\])',  'foo, a[0], bar')\n\n['', 'PROJECT', 'MODULE[]', 'CHARACTERISTIC[]']\n\n\n['foo, a', ', bar']\n\n\n\nprog = re.compile('(\\[\\d\\])')\nresult = prog.search('/PROJECT/MODULE[0]/CHARACTERISTIC[0]').group(1)\nprint(result)\n\n[0]\n\n\n\nre.search('(?:\\[(\\d)\\])',  'foo, a[0], bar').groups()\nre.search('(?:\\[(\\d,?\\s*\\d*)\\])',  'foo, a[0, 4], bar').groups()\n\n('0',)\n\n\n('0, 4',)\n\n\n\ntry:\n    res = re.search('(?:\\[(\\d+),?\\s*(\\d*)\\])',  'foo, a[0, 24], bar').groups()\n    print(res)\n    # re.search('(?:\\[(\\d,?\\s*\\d*)\\])', 'foo, a[0, 4], bar').groups()\nexcept AttributeError as exc:\n    print(exc)\n\n('0', '24')\n\n\n\ntry:\n    res = re.search('(?:\\[(\\d+),?\\s*(\\d*)\\])',  'foo, bar').groups()\n    print(res)\n    # re.search('(?:\\[(\\d,?\\d*)\\])',  'foo').groups()\nexcept AttributeError as exc:\n    print(exc)\n\n'NoneType' object has no attribute 'groups'\n\n\n\n# node_path = args.node_paths[0]\ntest_node_path = r\"/PROJECT[0]/MODULE[0,3,5]/IF_DATA[3:2:8]/CHARACTERISTIC[3:5]/TQD_trqTrqSetNormal_MAP_v\"\npath_segments = re.split(r'/\\s*', test_node_path)[1:]\nprint(path_segments)\n\n['PROJECT[0]', 'MODULE[0,3,5]', 'IF_DATA[3:2:8]', 'CHARACTERISTIC[3:5]', 'TQD_trqTrqSetNormal_MAP_v']\n\n\n\n# prefix = '.'.join(jnode_path.lazy_path.split('.')[:-1])\nprefix = JsonNodePath(args.node_path).lazy_path\nargs.path, prefix\nobjects = ijson.items(open(args.path, 'r'), prefix)\nmodule_items = list(objects)[0]\n# pprint(module_items)\npprint(module_items['CHARACTERISTIC'][0]['Name'])\nprint('\\n')\nl = {k:v for k,v in module_items['CHARACTERISTIC'][0]['AXIS_DESCR'][0].items()}\npprint(l)\n\n('/home/n/devel/candycan/res/vbu_sample.json', 'PROJECT.MODULE.item')\n\n\n{'Value': 'TQD_trqTrqSetNormal_MAP_v'}\n\n\n{'AXIS_PTS_REF': {'AxisPoints': {'Value': 'TQD_vSgndSpd_MAP_y'}},\n 'Attribute': 'COM_AXIS',\n 'Conversion': {'Value': 'VBU_L045A_CWP_05_09T_AImode_CM_single'},\n 'InputQuantity': {'Value': 'TQD_vVehSpd'},\n 'LowerLimit': {'DecimalSize': 5,\n                'IntegralSign': '-',\n                'IntegralSize': 1,\n                'Value': Decimal('-3.4E+38')},\n 'MaxAxisPoints': {'Base': 10, 'Size': 2, 'Value': 14},\n 'UpperLimit': {'DecimalSize': 5,\n                'IntegralSize': 1,\n                'Value': Decimal('3.4E+38')}}\n\n\n\nargs.path, args.node_path, args.leaves\n\n('/home/n/devel/candycan/res/vbu_sample.json',\n '/PROJECT/MODULE[], ',\n ['TQD_trqTrqSetNormal_MAP_v',\n  'VBU_L045A_CWP_05_09T_AImode_CM_single',\n  'Lookup2D_FLOAT32_IEEE',\n  'Lookup2D_X_FLOAT32_IEEE',\n  'Scalar_FLOAT32_IEEE',\n  'TQD_vVehSpd',\n  'TQD_vSgndSpd_MAP_y',\n  'TQD_pctAccPedPosFlt',\n  'TQD_pctAccPdl_MAP_x'])\n\n\n\ncalibs = []\nnode_paths = [r\"/PROJECT/MODULE[]/CHARACTERISTIC[]\",\n            r\"/PROJECT/MODULE[]/MEASUREMENT[]\",\n            r\"/PROJECT/MODULE[]/AXIS_PTS[]\",\n            r\"/PROJECT/MODULE[]/COMPU_METHOD[]\"]\njnode_paths = [JsonNodePath(p) for p in node_paths]\n\nfor jp in jnode_paths:\n    prefix = jp.lazy_path\n    objects = ijson.items(open(args.path, \"r\"), prefix)\n    # calib = [o for o in objects for k, v in o.items() if k == 'Name']\n    # pprint(calib)\n    # len(calib)\n    # print(prefix)\n    for o in objects:\n        for k, v in o.items():\n            if k == 'Name':\n                if v['Value'] in args.leaves:\n                    calibs.append(o)\n\npprint(calibs[3])\n# calib['LowerLimit']['Value'], calib['UpperLimit']['Value']\n    \n# for c in calibs:\n#   pprint(c)\n\n{'Address': {'Base': 16, 'Size': 8, 'Value': '1879071450'},\n 'Conversion': {'Value': 'VBU_L045A_CWP_05_09T_AImode_CM_single'},\n 'DepositR': {'Value': 'Lookup2D_X_FLOAT32_IEEE'},\n 'InputQuantity': {'Value': 'TQD_vVehSpd'},\n 'LongIdentifier': {},\n 'LowerLimit': {'DecimalSize': 5,\n                'IntegralSign': '-',\n                'IntegralSize': 1,\n                'Value': Decimal('-3.4E+38')},\n 'MaxAxisPoints': {'Base': 10, 'Size': 2, 'Value': 14},\n 'MaxDiff': {},\n 'Name': {'Value': 'TQD_vSgndSpd_MAP_y'},\n 'UpperLimit': {'DecimalSize': 5,\n                'IntegralSize': 1,\n                'Value': Decimal('3.4E+38')}}\n\n\n\n\n\nBunch\n\n Bunch (key, **kwargs)\n\ncollector of a bunch of named stuff into one object; a generic record/struct type, indexed by keys\n\n\n\nRecord\n\n Record (**kwargs)\n\nobject with dynamic attributes\n\n\n\nCalibration\n\n Calibration (**kwargs)\n\n*Target calibration object for torque map; a2l section [â€œPROJECTâ€][â€œMODULEâ€][â€œCHARACTERISTICâ€]\nFirst level keys will be turned into attributes of the object, encoded registered values will be replaced with the corresponding objects. Otherwiese the key-value pairs will be kept as is.*\n\n\n\nMeasurement\n\n Measurement (**kwargs)\n\nMeasurement object like speed, acc pedal position, etc; a2l section [â€œPROJECTâ€][â€œMODULEâ€][â€œMEAUREMENTâ€]]\n\n\n\nAxisScale\n\n AxisScale (**kwargs)\n\nTarget calibration object for torque map; a2l section [â€œPROJECTâ€][â€œMODULEâ€][â€œAXIS_PTSâ€]\n\n\n\nDataConversion\n\n DataConversion (**kwargs)\n\nData conversion object for calibration; a2l section [â€œPROJECTâ€][â€œMODULEâ€][â€œCOMPU_METHODâ€]]\n\n\n\nDataLayout\n\n DataLayout (**kwargs)\n\nData type object for calibration; a2l section [â€œPROJECTâ€][â€œMODULEâ€][â€œRECORD_LAYOUTâ€]\n\nRecord.subclass_registry\n\n{'CHARACTERISTIC': 'Calibration',\n 'MEASUREMENT': 'Measurement',\n 'AXIS_PTS': 'AxisScale',\n 'COMPU_METHOD': 'DataConversion',\n 'RECORD_LAYOUT': 'DataLayout'}\n\n\n\n\n\nload_class_type_a2l_lazy\n\n load_class_type_a2l_lazy (path:pathlib.Path,\n                           jnode_path:Optional[__main__.JsonNodePath]=&lt;Jso\n                           nNodePath [&lt;PROJECT dict&gt;, &lt;MODULE[] list&gt;]&gt;)\n\n*Search for the calibration key in the A2L file. Descripttion: Load the A2L file as a dictionary.\nCreate record type (enum class) for the calibration parameter for the given a2l json file\nArgs: path (str): The path to the A2L file. section_key (str): The section key to search for the calibration type.\nReturns: dict: The A2L file as a dictionary.*\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\npath\nPath\n\n\n\n\njnode_path\nOptionalJsonNodePath\n&lt;JsonNodePath [, &lt;MODULE[] list&gt;]&gt;\n\n\n\nReturns\ntype(Enum)\n\nreturn a class type\n\n\n\n\npprint(RecordTypes)\nset(RecordTypes.__members__.keys())\nRecord.record_registry\n\n&lt;enum 'RecordType'&gt;\n\n\n{'AXIS_PTS',\n 'CHARACTERISTIC',\n 'COMPU_METHOD',\n 'GROUP',\n 'IF_DATA',\n 'LongIdentifier',\n 'MEASUREMENT',\n 'MOD_COMMON',\n 'MOD_PAR',\n 'Name',\n 'RECORD_LAYOUT'}\n\n\n\n\n\nload_records_lazy\n\n load_records_lazy (path:pathlib.Path, leaves:list[str],\n                    jnode_path:Optional[__main__.JsonNodePath]=&lt;JsonNodePa\n                    th [&lt;PROJECT dict&gt;, &lt;MODULE[] list&gt;]&gt;)\n\n*load records from a json file lazily\nArgs: path (Path): path to the json file # use ijson no need for jnode_paths, though sacrificing a little bit efficiency (listJsonNodePath): list of JsonNodePath to the leaves leaves (list[str]): list of leaf indices to the records, needs to be unique and in the first item of the a2l json file\nReturns: dict[str, Record]: dict of Records and its subclasses, indexed by the leaf indices*\n\n# jnode_path = '.'.join(jnode_paths[0].lazy_path.split('.')[:-2])\nargs.path, args.leaves, args.node_path\n\n('/home/n/devel/candycan/res/vbu_sample.json',\n ['TQD_trqTrqSetNormal_MAP_v',\n  'VBU_L045A_CWP_05_09T_AImode_CM_single',\n  'Lookup2D_FLOAT32_IEEE',\n  'Lookup2D_X_FLOAT32_IEEE',\n  'Scalar_FLOAT32_IEEE',\n  'TQD_vVehSpd',\n  'TQD_vSgndSpd_MAP_y',\n  'TQD_pctAccPedPosFlt',\n  'TQD_pctAccPdl_MAP_x'],\n '/PROJECT/MODULE[], ')\n\n\n\nRecord.load_records(args.path, args.leaves, JsonNodePath(args.node_path)) #, jnode_path= args.node_path.lazy_path)\nRecord.subclass_registry\nsorted(Record.record_registry)\n\n{'CHARACTERISTIC': 'Calibration',\n 'MEASUREMENT': 'Measurement',\n 'AXIS_PTS': 'AxisScale',\n 'COMPU_METHOD': 'DataConversion',\n 'RECORD_LAYOUT': 'DataLayout'}\n\n\n['AxisScale.TQD_pctAccPdl_MAP_x',\n 'AxisScale.TQD_vSgndSpd_MAP_y',\n 'Calibration.TQD_trqTrqSetNormal_MAP_v',\n 'DataConversion.VBU_L045A_CWP_05_09T_AImode_CM_single',\n 'DataLayout.Lookup2D_FLOAT32_IEEE',\n 'DataLayout.Lookup2D_X_FLOAT32_IEEE',\n 'DataLayout.Scalar_FLOAT32_IEEE',\n 'Measurement.TQD_pctAccPedPosFlt',\n 'Measurement.TQD_vVehSpd']\n\n\n\nargs.leaves\n\n['TQD_trqTrqSetNormal_MAP_v',\n 'VBU_L045A_CWP_05_09T_AImode_CM_single',\n 'Lookup2D_FLOAT32_IEEE',\n 'Lookup2D_X_FLOAT32_IEEE',\n 'Scalar_FLOAT32_IEEE',\n 'TQD_vVehSpd',\n 'TQD_vSgndSpd_MAP_y',\n 'TQD_pctAccPedPosFlt',\n 'TQD_pctAccPdl_MAP_x']\n\n\n\nrecords = load_records_lazy(args.path, args.leaves, JsonNodePath(args.node_path))\npprint(list(records.keys()))\nlen(records)\nkey = 'AxisScale.' + args.leaves[6]\nprint(key)\nmeasurement = records[key]\nmeasurement, measurement.record_type, \nmeasurement.__dict__\nkey = 'AxisScale.' + args.leaves[8]\nprint(key)\nmeasurement = records[key]\nmeasurement, measurement.record_type, \nmeasurement.__dict__\n\n['Calibration.TQD_trqTrqSetNormal_MAP_v',\n 'Measurement.TQD_vVehSpd',\n 'Measurement.TQD_pctAccPedPosFlt',\n 'AxisScale.TQD_vSgndSpd_MAP_y',\n 'AxisScale.TQD_pctAccPdl_MAP_x',\n 'DataConversion.VBU_L045A_CWP_05_09T_AImode_CM_single',\n 'DataLayout.Scalar_FLOAT32_IEEE',\n 'DataLayout.Lookup2D_FLOAT32_IEEE',\n 'DataLayout.Lookup2D_X_FLOAT32_IEEE']\nAxisScale.TQD_vSgndSpd_MAP_y\nAxisScale.TQD_pctAccPdl_MAP_x\n\n\n9\n\n\n(&lt;AxisScale: 'TQD_vSgndSpd_MAP_y'&gt;, &lt;DataLayout: 'Lookup2D_X_FLOAT32_IEEE'&gt;)\n\n\n{'Name': 'TQD_vSgndSpd_MAP_y',\n 'LongIdentifier': {},\n 'Address': {'Value': '1879071450', 'Base': 16, 'Size': 8},\n 'InputQuantity': {'Value': 'TQD_vVehSpd'},\n 'DepositR': {'Value': 'Lookup2D_X_FLOAT32_IEEE'},\n 'MaxDiff': {},\n 'Conversion': {'Value': 'VBU_L045A_CWP_05_09T_AImode_CM_single'},\n 'MaxAxisPoints': {'Value': 14, 'Base': 10, 'Size': 2},\n 'LowerLimit': {'Value': Decimal('-3.4E+38'),\n  'IntegralSign': '-',\n  'IntegralSize': 1,\n  'DecimalSize': 5},\n 'UpperLimit': {'Value': Decimal('3.4E+38'),\n  'IntegralSize': 1,\n  'DecimalSize': 5},\n 'record_type': &lt;DataLayout: 'Lookup2D_X_FLOAT32_IEEE'&gt;}\n\n\n(&lt;AxisScale: 'TQD_pctAccPdl_MAP_x'&gt;, &lt;DataLayout: 'Lookup2D_X_FLOAT32_IEEE'&gt;)\n\n\n{'Name': 'TQD_pctAccPdl_MAP_x',\n 'LongIdentifier': {},\n 'Address': {'Value': '1879073310', 'Base': 16, 'Size': 8},\n 'InputQuantity': {'Value': 'TQD_pctAccPedPosFlt'},\n 'DepositR': {'Value': 'Lookup2D_X_FLOAT32_IEEE'},\n 'MaxDiff': {},\n 'Conversion': {'Value': 'VBU_L045A_CWP_05_09T_AImode_CM_single'},\n 'MaxAxisPoints': {'Value': 17, 'Base': 10, 'Size': 2},\n 'LowerLimit': {'Value': Decimal('-3.4E+38'),\n  'IntegralSign': '-',\n  'IntegralSize': 1,\n  'DecimalSize': 5},\n 'UpperLimit': {'Value': Decimal('3.4E+38'),\n  'IntegralSize': 1,\n  'DecimalSize': 5},\n 'record_type': &lt;DataLayout: 'Lookup2D_X_FLOAT32_IEEE'&gt;}\n\n\n\nkey = 'Measurement.' + args.leaves[5]\nprint(key)\nmeasurement = records[key]\nmeasurement, measurement.record_type, \nmeasurement.__dict__\nkey = 'Measurement.' + args.leaves[7]\nprint(key)\nmeasurement = records[key]\nmeasurement, measurement.record_type, \nmeasurement.__dict__\n\nMeasurement.TQD_vVehSpd\nMeasurement.TQD_pctAccPedPosFlt\n\n\n(&lt;Measurement: 'TQD_vVehSpd'&gt;, &lt;DataLayout: 'Scalar_FLOAT32_IEEE'&gt;)\n\n\n{'Name': 'TQD_vVehSpd',\n 'LongIdentifier': {},\n 'DataType': {'Value': 'FLOAT32_IEEE'},\n 'Conversion': {'Value': 'VBU_L045A_CWP_05_09T_AImode_CM_single'},\n 'Resolution': {'Base': 10, 'Size': 1},\n 'Accuracy': {},\n 'LowerLimit': {'Value': Decimal('-3.4E+38'),\n  'IntegralSign': '-',\n  'IntegralSize': 1,\n  'DecimalSize': 5},\n 'UpperLimit': {'Value': Decimal('3.4E+38'),\n  'IntegralSize': 1,\n  'DecimalSize': 5},\n 'ECU_ADDRESS': {'Address': {'Value': '1879113976', 'Base': 16, 'Size': 8}},\n 'record_type': &lt;DataLayout: 'Scalar_FLOAT32_IEEE'&gt;}\n\n\n(&lt;Measurement: 'TQD_pctAccPedPosFlt'&gt;, &lt;DataLayout: 'Scalar_FLOAT32_IEEE'&gt;)\n\n\n{'Name': 'TQD_pctAccPedPosFlt',\n 'LongIdentifier': {},\n 'DataType': {'Value': 'FLOAT32_IEEE'},\n 'Conversion': {'Value': 'VBU_L045A_CWP_05_09T_AImode_CM_single'},\n 'Resolution': {'Base': 10, 'Size': 1},\n 'Accuracy': {},\n 'LowerLimit': {'Value': Decimal('-3.4E+38'),\n  'IntegralSign': '-',\n  'IntegralSize': 1,\n  'DecimalSize': 5},\n 'UpperLimit': {'Value': Decimal('3.4E+38'),\n  'IntegralSize': 1,\n  'DecimalSize': 5},\n 'ECU_ADDRESS': {'Address': {'Value': '1879113888', 'Base': 16, 'Size': 8}},\n 'record_type': &lt;DataLayout: 'Scalar_FLOAT32_IEEE'&gt;}\n\n\n\nkey = 'DataLayout.' + args.leaves[4]\nprint(key)\nrecord_type = records[key]\nrecord_type, record_type.data_type, \nrecord_type.__dict__\nkey = 'DataLayout.' + args.leaves[3]\nprint(key)\nrecord_type = records[key]\nrecord_type, record_type.data_type, \nrecord_type.__dict__\n\nDataLayout.Scalar_FLOAT32_IEEE\nDataLayout.Lookup2D_X_FLOAT32_IEEE\n\n\n(&lt;DataLayout: 'Scalar_FLOAT32_IEEE'&gt;, 'FLOAT32_IEEE')\n\n\n{'Name': 'Scalar_FLOAT32_IEEE',\n 'FNC_VALUES': {'Position': {'Value': 1, 'Base': 10, 'Size': 1},\n  'DataType': {'Value': 'FLOAT32_IEEE'},\n  'IndexMode': 'COLUMN_DIR',\n  'AddressType': {'Value': 'DIRECT'}}}\n\n\n(&lt;DataLayout: 'Lookup2D_X_FLOAT32_IEEE'&gt;, 'FLOAT32_IEEE')\n\n\n{'Name': 'Lookup2D_X_FLOAT32_IEEE',\n 'AXIS_PTS_X': {'Position': {'Value': 1, 'Base': 10, 'Size': 1},\n  'DataType': {'Value': 'FLOAT32_IEEE'},\n  'IndexIncr': {'Value': 'INDEX_INCR'},\n  'Addressing': {'Value': 'DIRECT'}}}\n\n\n\nkey = 'Calibration.' + args.leaves[0]\nprint(key)\nrecords[key]\n\nCalibration.TQD_trqTrqSetNormal_MAP_v\n\n\n&lt;Calibration: 'TQD_trqTrqSetNormal_MAP_v'&gt;\n\n\n\ncalib = Record.fetch(key)\npprint(calib)\n\ncalib.axes[0].axis_scale.input\ncalib.axes[0].axis_scale.input.record_type\ncalib.axes[0].axis_scale.input.record_type.type_size\n\n&lt;Calibration: 'TQD_trqTrqSetNormal_MAP_v'&gt;\n\n\n&lt;Measurement: 'TQD_vVehSpd'&gt;\n\n\n&lt;DataLayout: 'Scalar_FLOAT32_IEEE'&gt;\n\n\n4\n\n\n\ncalib.record_type\ncalib.record_type.data_type\ncalib.record_type.type_size\ncalib.axes[0].axis_scale.record_type.type_size\n\n&lt;DataLayout: 'Lookup2D_FLOAT32_IEEE'&gt;\n\n\n'FLOAT32_IEEE'\n\n\n4\n\n\n4\n\n\n\ncalib.axes[0].axis_scale.input.record_type\ncalib.axes[0].axis_scale.input.record_type.type_size\ncalib.axes[0].axis_scale.data_conversion\ncalib.axes[0].data_conversion.Format\n\n&lt;DataLayout: 'Scalar_FLOAT32_IEEE'&gt;\n\n\n4\n\n\n&lt;DataConversion: 'VBU_L045A_CWP_05_09T_AImode_CM_single'&gt;\n\n\n{'Value': '%8.6'}\n\n\n\nfor k,v in records.items():\n    pprint(v)\n\npprint(records['Calibration.TQD_trqTrqSetNormal_MAP_v'].axes[0].measurement.data_conversion.Name)\n\n&lt;Calibration: 'TQD_trqTrqSetNormal_MAP_v'&gt;\n&lt;Measurement: 'TQD_vVehSpd'&gt;\n&lt;Measurement: 'TQD_pctAccPedPosFlt'&gt;\n&lt;AxisScale: 'TQD_vSgndSpd_MAP_y'&gt;\n&lt;AxisScale: 'TQD_pctAccPdl_MAP_x'&gt;\n&lt;DataConversion: 'VBU_L045A_CWP_05_09T_AImode_CM_single'&gt;\n&lt;DataLayout: 'Scalar_FLOAT32_IEEE'&gt;\n&lt;DataLayout: 'Lookup2D_FLOAT32_IEEE'&gt;\n&lt;DataLayout: 'Lookup2D_X_FLOAT32_IEEE'&gt;\n'VBU_L045A_CWP_05_09T_AImode_CM_single'\n\n\n\n'0' &lt; '1'\n\nTrue\n\n\n\n\n\nXCPConfig\n\n XCPConfig (channel:typing.Annotated[int,Ge(ge=0),Le(le=10000)]=3,\n            download:typing.Annotated[int,Ge(ge=0),Lt(lt=10000)]=630,\n            upload:typing.Annotated[int,Ge(ge=0),Lt(lt=10000)]=631)\n\nXCP configuration for the calibration parameter\n\nconfig = XCPConfig(channel=3, download=630, upload=631)\nc = config.model_dump()\npprint(c)\n# {**c}\n# type(config.download_can_id), config.download_can_id, config.channel\n# config.model_dump()\nconfig.model_json_schema()\n\n{'channel': 3, 'download_can_id': 630, 'upload_can_id': 631}\n\n\n{'description': 'XCP configuration for the calibration parameter',\n 'properties': {'channel': {'default': 3,\n   'description': 'XCP channel',\n   'maximum': 10000,\n   'minimum': 0,\n   'title': 'Channel',\n   'type': 'integer'},\n  'download': {'default': 630,\n   'description': 'CAN ID for downloading',\n   'exclusiveMaximum': 10000,\n   'minimum': 0,\n   'title': 'Download',\n   'type': 'integer'},\n  'upload': {'default': 631,\n   'description': 'CAN ID for uploading',\n   'exclusiveMaximum': 10000,\n   'minimum': 0,\n   'title': 'Upload',\n   'type': 'integer'}},\n 'title': 'XCPConfig',\n 'type': 'object'}\n\n\n\n\n\ncheck_a2l_type\n\n check_a2l_type (v:str)\n\n\nclass MyModel(BaseModel):\n    foo: A2LDataType\n\ntry:\n    m = MyModel(foo='FLOAT32_IEEE1')\nexcept ValidationError as exc:\n    print(exc)\n\n1 validation error for MyModel\nfoo\n  Assertion failed, Invalid data type FLOAT32_IEEE1 [type=assertion_error, input_value='FLOAT32_IEEE1', input_type=str]\n    For further information visit https://errors.pydantic.dev/2.6/v/assertion_error\n\n\n\nt = A2LDataType('FLOAT32_IEEE')\nt in type_collection\nt = A2LDataType(23)\nt\nt in type_collection\n\nTrue\n\n\n'23'\n\n\nFalse\n\n\n\n'FLOAT32_IEEE1' in type_collection\nt = A2LDataType('FLOAT32_IEEE1')\nt\nt in type_collection\nk\n\nFalse\n\n\n'FLOAT32_IEEE1'\n\n\nFalse\n\n\n'DataLayout.Lookup2D_X_FLOAT32_IEEE'\n\n\n\n# Testing forward referencing\nclass MyClass:\n    def __init__(self, value: int):\n        self.value = value\n\n    def compare(self, other: MyClass):  # this is default for python 3.7+ or \"other: 'MyClass'\"\n        if self.value &gt; other.value:\n            print(\"This instance has a greater value.\")\n        else:\n            print(\"The other instance has a greater or equal value.\")\n\n# Create instances\ninstance1 = MyClass(10)\ninstance2 = MyClass(5)\n\n# Call the compare method on instance1, passing instance2 as an argument\ninstance2.compare(instance1)  # Output: \"This instance has a greater value.\"\n\nThe other instance has a greater or equal value.\n\n\n\ndef func_a():\n    print(func_b())  # Forward reference to func_b\n\ndef func_b():\n    return \"Hello from func_b!\"\n\nfunc_a()  # Output: \"Hello from func_b!\"\n\nHello from func_b!\n\n\n\n\n\nXCPData\n\n XCPData (name:str='TQD_trqTrqSetNormal_MAP_v', address:Annotated[Optional\n          [str],_PydanticGeneralMetadata(pattern='^[0-9A-Fa-\n          f]{8}$')]='7000aa2a', dim:Annotated[List[Annotated[int,FieldInfo\n          (annotation=NoneType,required=True,frozen=True,metadata=[Gt(gt=0\n          ),Lt(lt=50)])]],Len(min_length=2,max_length=2)], value_type:typi\n          ng.Annotated[str,AfterValidator(func=&lt;functioncheck_a2l_typeat0x\n          7f1cede5ab60&gt;)]='FLOAT32_IEEE', value_length:typing.Annotated[in\n          t,Gt(gt=0),MultipleOf(multiple_of=2)]=4, value:typing.Annotated[\n          str,MinLen(min_length=1),MaxLen(max_length=3000),_PydanticGenera\n          lMetadata(pattern='^[0-9A-Fa-f]{0,3000}$')])\n\nXCP data for the calibration parameter\n\n\n\nGet_Init_XCPData\n\n Get_Init_XCPData\n                   (path:pathlib.Path=Path('../res/init_value_17rows.json'\n                   ))\n\n\ntry:\n    xcp_data_list = Get_Init_XCPData('../res/init_value_17rows.json')\n    len(xcp_data_list)\nexcept ValidationError as exc:\n    print(exc)\n# xcp_data[0], f'value byte length: {len(xcp_data[0].value)}'\n# xcp_data[1], f'value byte length: {len(xcp_data[1].value)}'\n\n2\n\n\n\nxcp_data_list[0].value_bytes[:2], f\"{xcp_data_list[0].value_bytes[:2].hex()}\"\nxcp_data_list[0]\nlen(xcp_data_list[0].value_bytes), len(xcp_data_list[0].value)\n\n(b'\\x1fZ', '1f5a')\n\n\n{   'address': '7000aa2a',\n    'dim': [21, 17],\n    'name': 'TQD_trqTrqSetNormal_MAP_v',\n    'type_size': 4,\n    'value': '1f5a84441f...444',\n    'value_array_view': array([[ 1058.816,  1058.816,  1058.816, ...,  4075.653,  4435.98 ,\n         4435.98 ],\n       [   70.079,   152.178,   234.277, ...,  4026.657,  4526.757,\n         4526.757],\n       [-3235.127, -1510.53 ,   214.067, ...,  4006.447,  4566.45 ,\n         4566.45 ],\n       ...,\n       [-2999.402, -2441.199, -1882.996, ...,  1958.867,  1984.853,\n         1984.853],\n       [-2973.497, -2419.99 , -1866.482, ...,  1810.322,  1826.58 ,\n         1826.58 ],\n       [-2946.278, -2461.24 , -1976.201, ...,  1667.968,  1826.58 ,\n         1826.58 ]], dtype=float32),\n    'value_bytes': \"b'\\\\x1f'...b'D'\",\n    'value_length': 4,\n    'value_type': 'FLOAT32_IEEE'}\n\n\n(1428, 2856)\n\n\n\nt = tuple(xcp_data_list[0].dim)\nt\nxcp_data_0 = xcp_data_list[0].value_array_view\nxcp_data_0\n\n(21, 17)\n\n\narray([[ 1058.816,  1058.816,  1058.816, ...,  4075.653,  4435.98 ,\n         4435.98 ],\n       [   70.079,   152.178,   234.277, ...,  4026.657,  4526.757,\n         4526.757],\n       [-3235.127, -1510.53 ,   214.067, ...,  4006.447,  4566.45 ,\n         4566.45 ],\n       ...,\n       [-2999.402, -2441.199, -1882.996, ...,  1958.867,  1984.853,\n         1984.853],\n       [-2973.497, -2419.99 , -1866.482, ...,  1810.322,  1826.58 ,\n         1826.58 ],\n       [-2946.278, -2461.24 , -1976.201, ...,  1667.968,  1826.58 ,\n         1826.58 ]], dtype=float32)\n\n\n\na = xcp_data_list[0].value_array_view\na.shape, a.dtype\na\n\n((21, 17), dtype('float32'))\n\n\narray([[ 1058.816,  1058.816,  1058.816, ...,  4075.653,  4435.98 ,\n         4435.98 ],\n       [   70.079,   152.178,   234.277, ...,  4026.657,  4526.757,\n         4526.757],\n       [-3235.127, -1510.53 ,   214.067, ...,  4006.447,  4566.45 ,\n         4566.45 ],\n       ...,\n       [-2999.402, -2441.199, -1882.996, ...,  1958.867,  1984.853,\n         1984.853],\n       [-2973.497, -2419.99 , -1866.482, ...,  1810.322,  1826.58 ,\n         1826.58 ],\n       [-2946.278, -2461.24 , -1976.201, ...,  1667.968,  1826.58 ,\n         1826.58 ]], dtype=float32)\n\n\n\n# xcp_data[0].hex_to_float(a)\n# s = ''.join([h[i:i+2] for i in range(0, len(h), 2)][::-1])\n# xcp_data[0].value\nb = bytes.fromhex(xcp_data_list[0].value)  # fromhex() takes a string and returns a bytes object\nb.hex()\nxcp_data_list[0].value\nb[0], b[1]\nhex(b[0])\nhex(b[1])\n\n'1f5a84441f5a84441f5a84441f5a84441f5a84441f5a84444ec38f44f1d9aa4494f0c5443707e14496d40445902519458a762d457f18564573ba7e45d79f8a45d79f8a4576288c42972d1843f3466a43057ee14349ec26448f195d446aa389440dbaa444b0d0bf4453e7da44a4c401459e15164599662a458d08534582aa7b450e768d450e768d4508324ac5f4d0bcc4381156432863d743dade2144200c5844b31c87445633a244f949bd449c60d8444881004543d214453d23294531c5514526677a459ab38e459ab38e4508e449c58f07c4c4118fbb4229579a4347e50244f99e3844ab586e442f09924408e6ac44e1c2c744270ef044b62c0c45595220459f9d4845e4e87045d79f8a45d79f8a45008149c5bf6002c5f6016dc43dfc3d435b8ac9434c0b1a446b514f44c54b8244d4ee9c44e391b7447a86df4488bd0345d4b717456bac3f4502a16745ccca8745d79f8a45f10849c5b2ed02c5d14973c49f8c14433d04b34316e10d440c404244039f7644fd7e954479aeaf44b2f5d644eb3cfe4412c212454b093a4584506145df4b8445d79f8a45da7b48c5f35c03c535f878c4201bdc4267f69d4303730244d2ea3544a1626944386d8e442029a844fcc2ce44d75cf54459fb0d4535953445102f5b4576e48045d79f8a45bbd947c5459011c5a08db6c46af513c4d7608a432782ef43bb512a4463e25c4485b98744d901a14457eec644d5daec44a963094527502f45a53c554523297b45d79f8a45942247c5d39711c5231ab8c43f091ac41f8770439096db43c8741f44481e5144e4638144a4389a44c577bf44e5b6e44402fb0445233a2a4543794f4563b87445dff58545665646c5338511c5ff67b9c4318b1fc470e64e435584c843b9ca144448534544d7db7544333293449e98b74409ffdb44ba3200452599244590ff4845fb656d45446c7145317545c56b5511c54b6bbac4815724c4549e3043651eb743d0f60a446d5e3a440ac66944d4968c448a24b04440b2d344f63ff744b12d1f4567bb4245dc916245dc916245f37e44c50b0319c5440edbc4731684c4877ab4c3be64a7430bf90144b73f304462865e4487668644881ba94489d0cb448a85ee44c6f71945c7ac3c45646b5345646b5345ae7343c5298718c54735dbc43d5c85c4c90cbec361579943d6a2f34325f72644e01c54444da18044997da244e559c4443036e64464f7144594b6354594b6354594b63545615342c59cf617c5ad33dbc4227a86c45c02c7c3cfe38b437eabe14397b91b446e9d46444581714484eb98446616b9444741d94485cb0c459ab325459ab325459ab325450d1e41c5074417c501d4dac4f41f87c49eafcdc3942081437d64d24333d4114428763a441c18634485059044fd7eae4474f8cc44b2f50445296f23453d2827453d282745b1d33fc58e6f16c5d616dac4914e87c42e19d2c3cf0f7243e3e0c443ef5c08446d492e44eb355444548c8644b2fda244116fbf44cd51f844d54d1845d54d1845d54d18454d743ec5cdd31ac59966eec49825a7c42fc93fc4ba1c45c3a575ba43da710044e1a82344e8df464473b27b447f429844c4abb2444f7ee7446d7309456d7309456d730945e1ff3cc582c419c54712edc4899ba6c4964940c46a704dc3c222b343e325f44382941a4412163b446bd86b44624d8e448eaea644e770d7445278024552780245527802456e763bc5309318c5e35febc46799a5c4d4a53fc46e6350c33be8ae436e80ea43510c13446bd83044918a5d445c1e85446f779b449629c844bcdbf4444e1bf8444e1bf844f3d739c5d53f17c56e4fe9c4311fa4c4eadd3dc4c5f54dc30fc6ad4355f3e3434e100d44f1262844e5c85044da6a7944670691445ca8b944504ae2448f52e4448f52e444712438c5d5d319c57206f7c43a65bac404887bc4944502c4403210c2977ee04378a00844a40121446793454429256a44765b874438edab44fb7ed0448f52e4448f52e444'\n\n\n'1f5a84441f5a84441f5a84441f5a84441f5a84441f5a84444ec38f44f1d9aa4494f0c5443707e14496d40445902519458a762d457f18564573ba7e45d79f8a45d79f8a4576288c42972d1843f3466a43057ee14349ec26448f195d446aa389440dbaa444b0d0bf4453e7da44a4c401459e15164599662a458d08534582aa7b450e768d450e768d4508324ac5f4d0bcc4381156432863d743dade2144200c5844b31c87445633a244f949bd449c60d8444881004543d214453d23294531c5514526677a459ab38e459ab38e4508e449c58f07c4c4118fbb4229579a4347e50244f99e3844ab586e442f09924408e6ac44e1c2c744270ef044b62c0c45595220459f9d4845e4e87045d79f8a45d79f8a45008149c5bf6002c5f6016dc43dfc3d435b8ac9434c0b1a446b514f44c54b8244d4ee9c44e391b7447a86df4488bd0345d4b717456bac3f4502a16745ccca8745d79f8a45f10849c5b2ed02c5d14973c49f8c14433d04b34316e10d440c404244039f7644fd7e954479aeaf44b2f5d644eb3cfe4412c212454b093a4584506145df4b8445d79f8a45da7b48c5f35c03c535f878c4201bdc4267f69d4303730244d2ea3544a1626944386d8e442029a844fcc2ce44d75cf54459fb0d4535953445102f5b4576e48045d79f8a45bbd947c5459011c5a08db6c46af513c4d7608a432782ef43bb512a4463e25c4485b98744d901a14457eec644d5daec44a963094527502f45a53c554523297b45d79f8a45942247c5d39711c5231ab8c43f091ac41f8770439096db43c8741f44481e5144e4638144a4389a44c577bf44e5b6e44402fb0445233a2a4543794f4563b87445dff58545665646c5338511c5ff67b9c4318b1fc470e64e435584c843b9ca144448534544d7db7544333293449e98b74409ffdb44ba3200452599244590ff4845fb656d45446c7145317545c56b5511c54b6bbac4815724c4549e3043651eb743d0f60a446d5e3a440ac66944d4968c448a24b04440b2d344f63ff744b12d1f4567bb4245dc916245dc916245f37e44c50b0319c5440edbc4731684c4877ab4c3be64a7430bf90144b73f304462865e4487668644881ba94489d0cb448a85ee44c6f71945c7ac3c45646b5345646b5345ae7343c5298718c54735dbc43d5c85c4c90cbec361579943d6a2f34325f72644e01c54444da18044997da244e559c4443036e64464f7144594b6354594b6354594b63545615342c59cf617c5ad33dbc4227a86c45c02c7c3cfe38b437eabe14397b91b446e9d46444581714484eb98446616b9444741d94485cb0c459ab325459ab325459ab325450d1e41c5074417c501d4dac4f41f87c49eafcdc3942081437d64d24333d4114428763a441c18634485059044fd7eae4474f8cc44b2f50445296f23453d2827453d282745b1d33fc58e6f16c5d616dac4914e87c42e19d2c3cf0f7243e3e0c443ef5c08446d492e44eb355444548c8644b2fda244116fbf44cd51f844d54d1845d54d1845d54d18454d743ec5cdd31ac59966eec49825a7c42fc93fc4ba1c45c3a575ba43da710044e1a82344e8df464473b27b447f429844c4abb2444f7ee7446d7309456d7309456d730945e1ff3cc582c419c54712edc4899ba6c4964940c46a704dc3c222b343e325f44382941a4412163b446bd86b44624d8e448eaea644e770d7445278024552780245527802456e763bc5309318c5e35febc46799a5c4d4a53fc46e6350c33be8ae436e80ea43510c13446bd83044918a5d445c1e85446f779b449629c844bcdbf4444e1bf8444e1bf844f3d739c5d53f17c56e4fe9c4311fa4c4eadd3dc4c5f54dc30fc6ad4355f3e3434e100d44f1262844e5c85044da6a7944670691445ca8b944504ae2448f52e4448f52e444712438c5d5d319c57206f7c43a65bac404887bc4944502c4403210c2977ee04378a00844a40121446793454429256a44765b874438edab44fb7ed0448f52e4448f52e444'\n\n\n(31, 90)\n\n\n'0x1f'\n\n\n'0x5a'\n\n\n\nbb = bytes.fromhex(xcp_data_list[0].value)[::-1]\nlen(bb), len(xcp_data_list[0].value), xcp_data_list[0].dim\nbb\n\n(1428, 2856, [21, 17])\n\n\nb'D\\xe4R\\x8fD\\xe4R\\x8fD\\xd0~\\xfbD\\xab\\xed8D\\x87[vDj%)DE\\x93gD!\\x01\\xa4D\\x08\\xa0xC\\xe0~\\x97\\xc2\\x102@\\xc4\\x02E\\x94\\xc4{\\x88\\x04\\xc4\\xbae:\\xc4\\xf7\\x06r\\xc5\\x19\\xd3\\xd5\\xc58$qD\\xe4R\\x8fD\\xe4R\\x8fD\\xe2JPD\\xb9\\xa8\\\\D\\x91\\x06gDyj\\xdaDP\\xc8\\xe5D(&\\xf1D\\r\\x10NC\\xe3\\xf3UC\\xad\\xc6\\x0f\\xc3M\\xf5\\xc5\\xc4=\\xdd\\xea\\xc4\\xa4\\x1f1\\xc4\\xe9On\\xc5\\x17?\\xd5\\xc59\\xd7\\xf3D\\xf8\\x1bND\\xf8\\x1bND\\xf4\\xdb\\xbcD\\xc8)\\x96D\\x9bwoD\\x85\\x1e\\\\D]\\x8a\\x91D0\\xd8kD\\x13\\x0cQC\\xea\\x80nC\\xae\\xe8;\\xc3Pcn\\xc4?\\xa5\\xd4\\xc4\\xa5\\x99g\\xc4\\xeb_\\xe3\\xc5\\x18\\x930\\xc5;vnE\\x02xRE\\x02xRE\\x02xRD\\xd7p\\xe7D\\xa6\\xae\\x8eD\\x8eMbDk\\xd8kD;\\x16\\x12D\\x1a\\x94\\x82C\\xf4%\\xe3C\\xb3\"\\xc2\\xc3Mpj\\xc4@I\\x96\\xc4\\xa6\\x9b\\x89\\xc4\\xed\\x12G\\xc5\\x19\\xc4\\x82\\xc5&lt;\\xff\\xe1E\\tsmE\\tsmE\\tsmD\\xe7~OD\\xb2\\xab\\xc4D\\x98B\\x7fD{\\xb2sDF\\xdf\\xe8D#\\xa8\\xe1D\\x00q\\xdaC\\xbau\\xa5\\xc3E\\x1c\\xba\\xc4?\\xc9/\\xc4\\xa7%\\x98\\xc4\\xeef\\x99\\xc5\\x1a\\xd3\\xcd\\xc5&gt;tME\\x18M\\xd5E\\x18M\\xd5E\\x18M\\xd5D\\xf8Q\\xcdD\\xbfo\\x11D\\xa2\\xfd\\xb2D\\x86\\x8cTDT5\\xebD.ImD\\x08\\\\\\xefC\\xc4\\xe0\\xe3Cr\\x0f\\xcf\\xc3\\xd2\\x19.\\xc4\\x87N\\x91\\xc4\\xda\\x16\\xd6\\xc5\\x16o\\x8e\\xc5?\\xd3\\xb1E\\'(=E\\'(=E#o)E\\x04\\xf5\\xb2D\\xcc\\xf8tD\\xae~\\xfdD\\x90\\x05\\x85Dc\\x18\\x1cD:v(D\\x11\\xd43C\\xd2d}C\\x81 \\x94\\xc3\\xcd\\xaf\\x9e\\xc4\\x87\\x1f\\xf4\\xc4\\xda\\xd4\\x01\\xc5\\x17D\\x07\\xc5A\\x1e\\rE%\\xb3\\x9aE%\\xb3\\x9aE%\\xb3\\x9aE\\x0c\\xcb\\x85D\\xd9AGD\\xb9\\x16fD\\x98\\xeb\\x84Dq\\x81EDF\\x9dnD\\x1b\\xb9\\x97C\\xe1\\xab~C\\x8b\\xe3\\xcf\\xc3\\xc7\\x02\\\\\\xc4\\x86z\"\\xc4\\xdb3\\xad\\xc5\\x17\\xf6\\x9c\\xc5BSaE5\\xb6\\x94E5\\xb6\\x94E5\\xb6\\x94E\\x14\\xf7dD\\xe660D\\xc4Y\\xe5D\\xa2}\\x99D\\x80\\xa1MDT\\x1c\\xe0D&\\xf7%C\\xf3\\xa2\\xd6C\\x99Wa\\xc3\\xbe\\x0c\\xc9\\xc4\\x85\\\\=\\xc4\\xdb5G\\xc5\\x18\\x87)\\xc5Cs\\xaeESkdESkdE&lt;\\xac\\xc7E\\x19\\xf7\\xc6D\\xee\\x85\\x8aD\\xcb\\xd0\\x89D\\xa9\\x1b\\x88D\\x86f\\x87D^\\x86bD0?\\xb7D\\x01\\xf9\\x0bC\\xa7d\\xbe\\xc3\\xb4z\\x87\\xc4\\x84\\x16s\\xc4\\xdb\\x0eD\\xc5\\x19\\x03\\x0b\\xc5D~\\xf3Eb\\x91\\xdcEb\\x91\\xdcEB\\xbbgE\\x1f-\\xb1D\\xf7?\\xf6D\\xd3\\xb2@D\\xb0$\\x8aD\\x8c\\x96\\xd4Di\\xc6\\nD:^mD\\n\\xf6\\xd0C\\xb7\\x1eeC0\\x9eT\\xc4$W\\x81\\xc4\\xbakK\\xc5\\x11Uk\\xc5Eu1EqlDEme\\xfbEH\\xff\\x90E$\\x99%E\\x002\\xbaD\\xdb\\xff\\tD\\xb7\\x98\\x9eD\\x9323Du\\xdb\\xd7DESHD\\x14\\xca\\xb9C\\xc8\\x84UCN\\xe6p\\xc4\\x1f\\x8b1\\xc4\\xb9g\\xff\\xc5\\x11\\x853\\xc5FVfE\\x85\\xf5\\xdfEt\\xb8cEOyCE*:#E\\x04\\xfb\\x02D\\xe4\\xb6\\xe5D\\xbfw\\xc5D\\x9a8\\xa4D\\x81c\\xe4DQ\\x1eHD\\x1ft\\xc8C\\xdb\\x96\\x90Cp\\x87\\x1f\\xc4\\x1a\\t?\\xc4\\xb8\\x1a#\\xc5\\x11\\x97\\xd3\\xc5G\"\\x94E\\x8a\\x9f\\xd7E{)#EU&lt;\\xa5E/P\\'E\\tc\\xa9D\\xec\\xda\\xd5D\\xc6\\xeeWD\\xa1\\x01\\xd9D\\x87\\xb9\\x85D\\\\\\xe2cD*Q\\xbbC\\xef\\x82\\'C\\x8a`\\xd7\\xc4\\x13\\xf5j\\xc4\\xb6\\x8d\\xa0\\xc5\\x11\\x90E\\xc5G\\xd9\\xbbE\\x8a\\x9f\\xd7E\\x80\\xe4vE[/\\x10E4\\x955E\\r\\xfbYD\\xf5\\\\\\xd7D\\xce\\xc2\\xfcD\\xa8) D\\x8em8Dib\\xa1D5\\xea\\xd2D\\x02s\\x03C\\x9d\\xf6gB\\xdc\\x1b \\xc4x\\xf85\\xc5\\x03\\\\\\xf3\\xc5H{\\xdaE\\x8a\\x9f\\xd7E\\x84K\\xdfEaP\\x84E:\\tKE\\x12\\xc2\\x12D\\xfe&lt;\\xebD\\xd6\\xf5\\xb2D\\xaf\\xaeyD\\x95~\\xfdDv\\x9f\\x03DB@\\x0cD\\r\\xe1\\x16C\\xb3\\x04=C\\x14\\x8c\\x9f\\xc4sI\\xd1\\xc5\\x02\\xed\\xb2\\xc5I\\x08\\xf1E\\x8a\\x9f\\xd7E\\x87\\xca\\xccEg\\xa1\\x02E?\\xackE\\x17\\xb7\\xd4E\\x03\\xbd\\x88D\\xdf\\x86zD\\xb7\\x91\\xe3D\\x9c\\xee\\xd4D\\x82K\\xc5DOQkD\\x1a\\x0bLC\\xc9\\x8a[C=\\xfc=\\xc4m\\x01\\xf6\\xc5\\x02`\\xbf\\xc5I\\x81\\x00E\\x8a\\x9f\\xd7E\\x8a\\x9f\\xd7Ep\\xe8\\xe4EH\\x9d\\x9fE RYE\\x0c,\\xb6D\\xf0\\x0e\\'D\\xc7\\xc2\\xe1D\\xac\\xe6\\x08D\\x92\\t/DnX\\xabD8\\x9e\\xf9D\\x02\\xe5GC\\x9aW)B\\xbb\\x8f\\x11\\xc4\\xc4\\x07\\x8f\\xc5I\\xe4\\x08E\\x8e\\xb3\\x9aE\\x8e\\xb3\\x9aEzg&EQ\\xc51E)#=E\\x14\\xd2CE\\x00\\x81HD\\xd8`\\x9cD\\xbdI\\xf9D\\xa23VD\\x87\\x1c\\xb3DX\\x0c D!\\xde\\xdaC\\xd7c(CV\\x118\\xc4\\xbc\\xd0\\xf4\\xc5J2\\x08E\\x8dv\\x0eE\\x8dv\\x0eE{\\xaa\\x82ES\\x08\\x8dE*f\\x99E\\x16\\x15\\x9eE\\x01\\xc4\\xa4D\\xda\\xe7SD\\xbf\\xd0\\xb0D\\xa4\\xba\\rD\\x89\\xa3jD]\\x19\\x8fD&\\xecIC\\xe1~\\x05CjF\\xf3C\\x18-\\x97B\\x8c(vE\\x8a\\x9f\\xd7E\\x8a\\x9f\\xd7E~\\xbasEV\\x18\\x7fE-v\\x8aE\\x19%\\x90E\\x04\\xd4\\x96D\\xe1\\x077D\\xc5\\xf0\\x94D\\xaa\\xd9\\xf1D\\x8f\\xc3ND\\x84Z\\x1fD\\x84Z\\x1fD\\x84Z\\x1fD\\x84Z\\x1fD\\x84Z\\x1fD\\x84Z\\x1f'\n\n\n\n# bb = b[::-1]\na = [struct.unpack('!f',bb[i:i+4])[0] for i in range(0, len(bb), 4)]\nn = np.array(a)\nn\n\narray([1826.58 , 1826.58 , 1667.968, ..., 1058.816, 1058.816, 1058.816])\n\n\n\nlen(xcp_data_list[0].value), xcp_data_list[0].value\nlen(bytes.fromhex(xcp_data_list[0].value)), bytes.fromhex(xcp_data_list[0].value)\nlen(xcp_data_list[0].value_bytes), xcp_data_list[0].value_bytes\nxcp_data_list[0].dim, xcp_data_list[0].value_array_view.dtype\nxcp_data_list[0].value_array_view\n\n(2856,\n '1f5a84441f5a84441f5a84441f5a84441f5a84441f5a84444ec38f44f1d9aa4494f0c5443707e14496d40445902519458a762d457f18564573ba7e45d79f8a45d79f8a4576288c42972d1843f3466a43057ee14349ec26448f195d446aa389440dbaa444b0d0bf4453e7da44a4c401459e15164599662a458d08534582aa7b450e768d450e768d4508324ac5f4d0bcc4381156432863d743dade2144200c5844b31c87445633a244f949bd449c60d8444881004543d214453d23294531c5514526677a459ab38e459ab38e4508e449c58f07c4c4118fbb4229579a4347e50244f99e3844ab586e442f09924408e6ac44e1c2c744270ef044b62c0c45595220459f9d4845e4e87045d79f8a45d79f8a45008149c5bf6002c5f6016dc43dfc3d435b8ac9434c0b1a446b514f44c54b8244d4ee9c44e391b7447a86df4488bd0345d4b717456bac3f4502a16745ccca8745d79f8a45f10849c5b2ed02c5d14973c49f8c14433d04b34316e10d440c404244039f7644fd7e954479aeaf44b2f5d644eb3cfe4412c212454b093a4584506145df4b8445d79f8a45da7b48c5f35c03c535f878c4201bdc4267f69d4303730244d2ea3544a1626944386d8e442029a844fcc2ce44d75cf54459fb0d4535953445102f5b4576e48045d79f8a45bbd947c5459011c5a08db6c46af513c4d7608a432782ef43bb512a4463e25c4485b98744d901a14457eec644d5daec44a963094527502f45a53c554523297b45d79f8a45942247c5d39711c5231ab8c43f091ac41f8770439096db43c8741f44481e5144e4638144a4389a44c577bf44e5b6e44402fb0445233a2a4543794f4563b87445dff58545665646c5338511c5ff67b9c4318b1fc470e64e435584c843b9ca144448534544d7db7544333293449e98b74409ffdb44ba3200452599244590ff4845fb656d45446c7145317545c56b5511c54b6bbac4815724c4549e3043651eb743d0f60a446d5e3a440ac66944d4968c448a24b04440b2d344f63ff744b12d1f4567bb4245dc916245dc916245f37e44c50b0319c5440edbc4731684c4877ab4c3be64a7430bf90144b73f304462865e4487668644881ba94489d0cb448a85ee44c6f71945c7ac3c45646b5345646b5345ae7343c5298718c54735dbc43d5c85c4c90cbec361579943d6a2f34325f72644e01c54444da18044997da244e559c4443036e64464f7144594b6354594b6354594b63545615342c59cf617c5ad33dbc4227a86c45c02c7c3cfe38b437eabe14397b91b446e9d46444581714484eb98446616b9444741d94485cb0c459ab325459ab325459ab325450d1e41c5074417c501d4dac4f41f87c49eafcdc3942081437d64d24333d4114428763a441c18634485059044fd7eae4474f8cc44b2f50445296f23453d2827453d282745b1d33fc58e6f16c5d616dac4914e87c42e19d2c3cf0f7243e3e0c443ef5c08446d492e44eb355444548c8644b2fda244116fbf44cd51f844d54d1845d54d1845d54d18454d743ec5cdd31ac59966eec49825a7c42fc93fc4ba1c45c3a575ba43da710044e1a82344e8df464473b27b447f429844c4abb2444f7ee7446d7309456d7309456d730945e1ff3cc582c419c54712edc4899ba6c4964940c46a704dc3c222b343e325f44382941a4412163b446bd86b44624d8e448eaea644e770d7445278024552780245527802456e763bc5309318c5e35febc46799a5c4d4a53fc46e6350c33be8ae436e80ea43510c13446bd83044918a5d445c1e85446f779b449629c844bcdbf4444e1bf8444e1bf844f3d739c5d53f17c56e4fe9c4311fa4c4eadd3dc4c5f54dc30fc6ad4355f3e3434e100d44f1262844e5c85044da6a7944670691445ca8b944504ae2448f52e4448f52e444712438c5d5d319c57206f7c43a65bac404887bc4944502c4403210c2977ee04378a00844a40121446793454429256a44765b874438edab44fb7ed0448f52e4448f52e444')\n\n\n(1428,\n b'\\x1fZ\\x84D\\x1fZ\\x84D\\x1fZ\\x84D\\x1fZ\\x84D\\x1fZ\\x84D\\x1fZ\\x84DN\\xc3\\x8fD\\xf1\\xd9\\xaaD\\x94\\xf0\\xc5D7\\x07\\xe1D\\x96\\xd4\\x04E\\x90%\\x19E\\x8av-E\\x7f\\x18VEs\\xba~E\\xd7\\x9f\\x8aE\\xd7\\x9f\\x8aEv(\\x8cB\\x97-\\x18C\\xf3FjC\\x05~\\xe1CI\\xec&D\\x8f\\x19]Dj\\xa3\\x89D\\r\\xba\\xa4D\\xb0\\xd0\\xbfDS\\xe7\\xdaD\\xa4\\xc4\\x01E\\x9e\\x15\\x16E\\x99f*E\\x8d\\x08SE\\x82\\xaa{E\\x0ev\\x8dE\\x0ev\\x8dE\\x082J\\xc5\\xf4\\xd0\\xbc\\xc48\\x11VC(c\\xd7C\\xda\\xde!D \\x0cXD\\xb3\\x1c\\x87DV3\\xa2D\\xf9I\\xbdD\\x9c`\\xd8DH\\x81\\x00EC\\xd2\\x14E=#)E1\\xc5QE&gzE\\x9a\\xb3\\x8eE\\x9a\\xb3\\x8eE\\x08\\xe4I\\xc5\\x8f\\x07\\xc4\\xc4\\x11\\x8f\\xbbB)W\\x9aCG\\xe5\\x02D\\xf9\\x9e8D\\xabXnD/\\t\\x92D\\x08\\xe6\\xacD\\xe1\\xc2\\xc7D\\'\\x0e\\xf0D\\xb6,\\x0cEYR E\\x9f\\x9dHE\\xe4\\xe8pE\\xd7\\x9f\\x8aE\\xd7\\x9f\\x8aE\\x00\\x81I\\xc5\\xbf`\\x02\\xc5\\xf6\\x01m\\xc4=\\xfc=C[\\x8a\\xc9CL\\x0b\\x1aDkQOD\\xc5K\\x82D\\xd4\\xee\\x9cD\\xe3\\x91\\xb7Dz\\x86\\xdfD\\x88\\xbd\\x03E\\xd4\\xb7\\x17Ek\\xac?E\\x02\\xa1gE\\xcc\\xca\\x87E\\xd7\\x9f\\x8aE\\xf1\\x08I\\xc5\\xb2\\xed\\x02\\xc5\\xd1Is\\xc4\\x9f\\x8c\\x14C=\\x04\\xb3C\\x16\\xe1\\rD\\x0c@BD\\x03\\x9fvD\\xfd~\\x95Dy\\xae\\xafD\\xb2\\xf5\\xd6D\\xeb&lt;\\xfeD\\x12\\xc2\\x12EK\\t:E\\x84PaE\\xdfK\\x84E\\xd7\\x9f\\x8aE\\xda{H\\xc5\\xf3\\\\\\x03\\xc55\\xf8x\\xc4 \\x1b\\xdcBg\\xf6\\x9dC\\x03s\\x02D\\xd2\\xea5D\\xa1biD8m\\x8eD )\\xa8D\\xfc\\xc2\\xceD\\xd7\\\\\\xf5DY\\xfb\\rE5\\x954E\\x10/[Ev\\xe4\\x80E\\xd7\\x9f\\x8aE\\xbb\\xd9G\\xc5E\\x90\\x11\\xc5\\xa0\\x8d\\xb6\\xc4j\\xf5\\x13\\xc4\\xd7`\\x8aC\\'\\x82\\xefC\\xbbQ*Dc\\xe2\\\\D\\x85\\xb9\\x87D\\xd9\\x01\\xa1DW\\xee\\xc6D\\xd5\\xda\\xecD\\xa9c\\tE\\'P/E\\xa5&lt;UE#){E\\xd7\\x9f\\x8aE\\x94\"G\\xc5\\xd3\\x97\\x11\\xc5#\\x1a\\xb8\\xc4?\\t\\x1a\\xc4\\x1f\\x87pC\\x90\\x96\\xdbC\\xc8t\\x1fDH\\x1eQD\\xe4c\\x81D\\xa48\\x9aD\\xc5w\\xbfD\\xe5\\xb6\\xe4D\\x02\\xfb\\x04E#:*ECyOEc\\xb8tE\\xdf\\xf5\\x85EfVF\\xc53\\x85\\x11\\xc5\\xffg\\xb9\\xc41\\x8b\\x1f\\xc4p\\xe6NCU\\x84\\xc8C\\xb9\\xca\\x14DHSED\\xd7\\xdbuD32\\x93D\\x9e\\x98\\xb7D\\t\\xff\\xdbD\\xba2\\x00E%\\x99$E\\x90\\xffHE\\xfbemEDlqE1uE\\xc5kU\\x11\\xc5Kk\\xba\\xc4\\x81W$\\xc4T\\x9e0Ce\\x1e\\xb7C\\xd0\\xf6\\nDm^:D\\n\\xc6iD\\xd4\\x96\\x8cD\\x8a$\\xb0D@\\xb2\\xd3D\\xf6?\\xf7D\\xb1-\\x1fEg\\xbbBE\\xdc\\x91bE\\xdc\\x91bE\\xf3~D\\xc5\\x0b\\x03\\x19\\xc5D\\x0e\\xdb\\xc4s\\x16\\x84\\xc4\\x87z\\xb4\\xc3\\xbed\\xa7C\\x0b\\xf9\\x01D\\xb7?0Db\\x86^D\\x87f\\x86D\\x88\\x1b\\xa9D\\x89\\xd0\\xcbD\\x8a\\x85\\xeeD\\xc6\\xf7\\x19E\\xc7\\xac&lt;EdkSEdkSE\\xaesC\\xc5)\\x87\\x18\\xc5G5\\xdb\\xc4=\\\\\\x85\\xc4\\xc9\\x0c\\xbe\\xc3aW\\x99C\\xd6\\xa2\\xf3C%\\xf7&D\\xe0\\x1cTDM\\xa1\\x80D\\x99}\\xa2D\\xe5Y\\xc4D06\\xe6Dd\\xf7\\x14E\\x94\\xb65E\\x94\\xb65E\\x94\\xb65EaSB\\xc5\\x9c\\xf6\\x17\\xc5\\xad3\\xdb\\xc4\"z\\x86\\xc4\\\\\\x02\\xc7\\xc3\\xcf\\xe3\\x8bC~\\xab\\xe1C\\x97\\xb9\\x1bDn\\x9dFDE\\x81qD\\x84\\xeb\\x98Df\\x16\\xb9DGA\\xd9D\\x85\\xcb\\x0cE\\x9a\\xb3%E\\x9a\\xb3%E\\x9a\\xb3%E\\r\\x1eA\\xc5\\x07D\\x17\\xc5\\x01\\xd4\\xda\\xc4\\xf4\\x1f\\x87\\xc4\\x9e\\xaf\\xcd\\xc3\\x94 \\x81C}d\\xd2C3\\xd4\\x11D(v:D\\x1c\\x18cD\\x85\\x05\\x90D\\xfd~\\xaeDt\\xf8\\xccD\\xb2\\xf5\\x04E)o#E=(\\'E=(\\'E\\xb1\\xd3?\\xc5\\x8eo\\x16\\xc5\\xd6\\x16\\xda\\xc4\\x91N\\x87\\xc4.\\x19\\xd2\\xc3\\xcf\\x0frC\\xe3\\xe0\\xc4C\\xef\\\\\\x08DmI.D\\xeb5TDT\\x8c\\x86D\\xb2\\xfd\\xa2D\\x11o\\xbfD\\xcdQ\\xf8D\\xd5M\\x18E\\xd5M\\x18E\\xd5M\\x18EMt&gt;\\xc5\\xcd\\xd3\\x1a\\xc5\\x99f\\xee\\xc4\\x98%\\xa7\\xc4/\\xc9?\\xc4\\xba\\x1cE\\xc3\\xa5u\\xbaC\\xdaq\\x00D\\xe1\\xa8#D\\xe8\\xdfFDs\\xb2{D\\x7fB\\x98D\\xc4\\xab\\xb2DO~\\xe7Dms\\tEms\\tEms\\tE\\xe1\\xff&lt;\\xc5\\x82\\xc4\\x19\\xc5G\\x12\\xed\\xc4\\x89\\x9b\\xa6\\xc4\\x96I@\\xc4jpM\\xc3\\xc2\"\\xb3C\\xe3%\\xf4C\\x82\\x94\\x1aD\\x12\\x16;Dk\\xd8kDbM\\x8eD\\x8e\\xae\\xa6D\\xe7p\\xd7DRx\\x02ERx\\x02ERx\\x02Env;\\xc50\\x93\\x18\\xc5\\xe3_\\xeb\\xc4g\\x99\\xa5\\xc4\\xd4\\xa5?\\xc4ncP\\xc3;\\xe8\\xaeCn\\x80\\xeaCQ\\x0c\\x13Dk\\xd80D\\x91\\x8a]D\\\\\\x1e\\x85Dow\\x9bD\\x96)\\xc8D\\xbc\\xdb\\xf4DN\\x1b\\xf8DN\\x1b\\xf8D\\xf3\\xd79\\xc5\\xd5?\\x17\\xc5nO\\xe9\\xc41\\x1f\\xa4\\xc4\\xea\\xdd=\\xc4\\xc5\\xf5M\\xc3\\x0f\\xc6\\xadCU\\xf3\\xe3CN\\x10\\rD\\xf1&(D\\xe5\\xc8PD\\xdajyDg\\x06\\x91D\\\\\\xa8\\xb9DPJ\\xe2D\\x8fR\\xe4D\\x8fR\\xe4Dq$8\\xc5\\xd5\\xd3\\x19\\xc5r\\x06\\xf7\\xc4:e\\xba\\xc4\\x04\\x88{\\xc4\\x94E\\x02\\xc4@2\\x10\\xc2\\x97~\\xe0Cx\\xa0\\x08D\\xa4\\x01!Dg\\x93ED)%jDv[\\x87D8\\xed\\xabD\\xfb~\\xd0D\\x8fR\\xe4D\\x8fR\\xe4D')\n\n\n(1428,\n b'\\x1fZ\\x84D\\x1fZ\\x84D\\x1fZ\\x84D\\x1fZ\\x84D\\x1fZ\\x84D\\x1fZ\\x84DN\\xc3\\x8fD\\xf1\\xd9\\xaaD\\x94\\xf0\\xc5D7\\x07\\xe1D\\x96\\xd4\\x04E\\x90%\\x19E\\x8av-E\\x7f\\x18VEs\\xba~E\\xd7\\x9f\\x8aE\\xd7\\x9f\\x8aEv(\\x8cB\\x97-\\x18C\\xf3FjC\\x05~\\xe1CI\\xec&D\\x8f\\x19]Dj\\xa3\\x89D\\r\\xba\\xa4D\\xb0\\xd0\\xbfDS\\xe7\\xdaD\\xa4\\xc4\\x01E\\x9e\\x15\\x16E\\x99f*E\\x8d\\x08SE\\x82\\xaa{E\\x0ev\\x8dE\\x0ev\\x8dE\\x082J\\xc5\\xf4\\xd0\\xbc\\xc48\\x11VC(c\\xd7C\\xda\\xde!D \\x0cXD\\xb3\\x1c\\x87DV3\\xa2D\\xf9I\\xbdD\\x9c`\\xd8DH\\x81\\x00EC\\xd2\\x14E=#)E1\\xc5QE&gzE\\x9a\\xb3\\x8eE\\x9a\\xb3\\x8eE\\x08\\xe4I\\xc5\\x8f\\x07\\xc4\\xc4\\x11\\x8f\\xbbB)W\\x9aCG\\xe5\\x02D\\xf9\\x9e8D\\xabXnD/\\t\\x92D\\x08\\xe6\\xacD\\xe1\\xc2\\xc7D\\'\\x0e\\xf0D\\xb6,\\x0cEYR E\\x9f\\x9dHE\\xe4\\xe8pE\\xd7\\x9f\\x8aE\\xd7\\x9f\\x8aE\\x00\\x81I\\xc5\\xbf`\\x02\\xc5\\xf6\\x01m\\xc4=\\xfc=C[\\x8a\\xc9CL\\x0b\\x1aDkQOD\\xc5K\\x82D\\xd4\\xee\\x9cD\\xe3\\x91\\xb7Dz\\x86\\xdfD\\x88\\xbd\\x03E\\xd4\\xb7\\x17Ek\\xac?E\\x02\\xa1gE\\xcc\\xca\\x87E\\xd7\\x9f\\x8aE\\xf1\\x08I\\xc5\\xb2\\xed\\x02\\xc5\\xd1Is\\xc4\\x9f\\x8c\\x14C=\\x04\\xb3C\\x16\\xe1\\rD\\x0c@BD\\x03\\x9fvD\\xfd~\\x95Dy\\xae\\xafD\\xb2\\xf5\\xd6D\\xeb&lt;\\xfeD\\x12\\xc2\\x12EK\\t:E\\x84PaE\\xdfK\\x84E\\xd7\\x9f\\x8aE\\xda{H\\xc5\\xf3\\\\\\x03\\xc55\\xf8x\\xc4 \\x1b\\xdcBg\\xf6\\x9dC\\x03s\\x02D\\xd2\\xea5D\\xa1biD8m\\x8eD )\\xa8D\\xfc\\xc2\\xceD\\xd7\\\\\\xf5DY\\xfb\\rE5\\x954E\\x10/[Ev\\xe4\\x80E\\xd7\\x9f\\x8aE\\xbb\\xd9G\\xc5E\\x90\\x11\\xc5\\xa0\\x8d\\xb6\\xc4j\\xf5\\x13\\xc4\\xd7`\\x8aC\\'\\x82\\xefC\\xbbQ*Dc\\xe2\\\\D\\x85\\xb9\\x87D\\xd9\\x01\\xa1DW\\xee\\xc6D\\xd5\\xda\\xecD\\xa9c\\tE\\'P/E\\xa5&lt;UE#){E\\xd7\\x9f\\x8aE\\x94\"G\\xc5\\xd3\\x97\\x11\\xc5#\\x1a\\xb8\\xc4?\\t\\x1a\\xc4\\x1f\\x87pC\\x90\\x96\\xdbC\\xc8t\\x1fDH\\x1eQD\\xe4c\\x81D\\xa48\\x9aD\\xc5w\\xbfD\\xe5\\xb6\\xe4D\\x02\\xfb\\x04E#:*ECyOEc\\xb8tE\\xdf\\xf5\\x85EfVF\\xc53\\x85\\x11\\xc5\\xffg\\xb9\\xc41\\x8b\\x1f\\xc4p\\xe6NCU\\x84\\xc8C\\xb9\\xca\\x14DHSED\\xd7\\xdbuD32\\x93D\\x9e\\x98\\xb7D\\t\\xff\\xdbD\\xba2\\x00E%\\x99$E\\x90\\xffHE\\xfbemEDlqE1uE\\xc5kU\\x11\\xc5Kk\\xba\\xc4\\x81W$\\xc4T\\x9e0Ce\\x1e\\xb7C\\xd0\\xf6\\nDm^:D\\n\\xc6iD\\xd4\\x96\\x8cD\\x8a$\\xb0D@\\xb2\\xd3D\\xf6?\\xf7D\\xb1-\\x1fEg\\xbbBE\\xdc\\x91bE\\xdc\\x91bE\\xf3~D\\xc5\\x0b\\x03\\x19\\xc5D\\x0e\\xdb\\xc4s\\x16\\x84\\xc4\\x87z\\xb4\\xc3\\xbed\\xa7C\\x0b\\xf9\\x01D\\xb7?0Db\\x86^D\\x87f\\x86D\\x88\\x1b\\xa9D\\x89\\xd0\\xcbD\\x8a\\x85\\xeeD\\xc6\\xf7\\x19E\\xc7\\xac&lt;EdkSEdkSE\\xaesC\\xc5)\\x87\\x18\\xc5G5\\xdb\\xc4=\\\\\\x85\\xc4\\xc9\\x0c\\xbe\\xc3aW\\x99C\\xd6\\xa2\\xf3C%\\xf7&D\\xe0\\x1cTDM\\xa1\\x80D\\x99}\\xa2D\\xe5Y\\xc4D06\\xe6Dd\\xf7\\x14E\\x94\\xb65E\\x94\\xb65E\\x94\\xb65EaSB\\xc5\\x9c\\xf6\\x17\\xc5\\xad3\\xdb\\xc4\"z\\x86\\xc4\\\\\\x02\\xc7\\xc3\\xcf\\xe3\\x8bC~\\xab\\xe1C\\x97\\xb9\\x1bDn\\x9dFDE\\x81qD\\x84\\xeb\\x98Df\\x16\\xb9DGA\\xd9D\\x85\\xcb\\x0cE\\x9a\\xb3%E\\x9a\\xb3%E\\x9a\\xb3%E\\r\\x1eA\\xc5\\x07D\\x17\\xc5\\x01\\xd4\\xda\\xc4\\xf4\\x1f\\x87\\xc4\\x9e\\xaf\\xcd\\xc3\\x94 \\x81C}d\\xd2C3\\xd4\\x11D(v:D\\x1c\\x18cD\\x85\\x05\\x90D\\xfd~\\xaeDt\\xf8\\xccD\\xb2\\xf5\\x04E)o#E=(\\'E=(\\'E\\xb1\\xd3?\\xc5\\x8eo\\x16\\xc5\\xd6\\x16\\xda\\xc4\\x91N\\x87\\xc4.\\x19\\xd2\\xc3\\xcf\\x0frC\\xe3\\xe0\\xc4C\\xef\\\\\\x08DmI.D\\xeb5TDT\\x8c\\x86D\\xb2\\xfd\\xa2D\\x11o\\xbfD\\xcdQ\\xf8D\\xd5M\\x18E\\xd5M\\x18E\\xd5M\\x18EMt&gt;\\xc5\\xcd\\xd3\\x1a\\xc5\\x99f\\xee\\xc4\\x98%\\xa7\\xc4/\\xc9?\\xc4\\xba\\x1cE\\xc3\\xa5u\\xbaC\\xdaq\\x00D\\xe1\\xa8#D\\xe8\\xdfFDs\\xb2{D\\x7fB\\x98D\\xc4\\xab\\xb2DO~\\xe7Dms\\tEms\\tEms\\tE\\xe1\\xff&lt;\\xc5\\x82\\xc4\\x19\\xc5G\\x12\\xed\\xc4\\x89\\x9b\\xa6\\xc4\\x96I@\\xc4jpM\\xc3\\xc2\"\\xb3C\\xe3%\\xf4C\\x82\\x94\\x1aD\\x12\\x16;Dk\\xd8kDbM\\x8eD\\x8e\\xae\\xa6D\\xe7p\\xd7DRx\\x02ERx\\x02ERx\\x02Env;\\xc50\\x93\\x18\\xc5\\xe3_\\xeb\\xc4g\\x99\\xa5\\xc4\\xd4\\xa5?\\xc4ncP\\xc3;\\xe8\\xaeCn\\x80\\xeaCQ\\x0c\\x13Dk\\xd80D\\x91\\x8a]D\\\\\\x1e\\x85Dow\\x9bD\\x96)\\xc8D\\xbc\\xdb\\xf4DN\\x1b\\xf8DN\\x1b\\xf8D\\xf3\\xd79\\xc5\\xd5?\\x17\\xc5nO\\xe9\\xc41\\x1f\\xa4\\xc4\\xea\\xdd=\\xc4\\xc5\\xf5M\\xc3\\x0f\\xc6\\xadCU\\xf3\\xe3CN\\x10\\rD\\xf1&(D\\xe5\\xc8PD\\xdajyDg\\x06\\x91D\\\\\\xa8\\xb9DPJ\\xe2D\\x8fR\\xe4D\\x8fR\\xe4Dq$8\\xc5\\xd5\\xd3\\x19\\xc5r\\x06\\xf7\\xc4:e\\xba\\xc4\\x04\\x88{\\xc4\\x94E\\x02\\xc4@2\\x10\\xc2\\x97~\\xe0Cx\\xa0\\x08D\\xa4\\x01!Dg\\x93ED)%jDv[\\x87D8\\xed\\xabD\\xfb~\\xd0D\\x8fR\\xe4D\\x8fR\\xe4D')\n\n\n([21, 17], dtype('float32'))\n\n\narray([[ 1058.816,  1058.816,  1058.816, ...,  4075.653,  4435.98 ,\n         4435.98 ],\n       [   70.079,   152.178,   234.277, ...,  4026.657,  4526.757,\n         4526.757],\n       [-3235.127, -1510.53 ,   214.067, ...,  4006.447,  4566.45 ,\n         4566.45 ],\n       ...,\n       [-2999.402, -2441.199, -1882.996, ...,  1958.867,  1984.853,\n         1984.853],\n       [-2973.497, -2419.99 , -1866.482, ...,  1810.322,  1826.58 ,\n         1826.58 ],\n       [-2946.278, -2461.24 , -1976.201, ...,  1667.968,  1826.58 ,\n         1826.58 ]], dtype=float32)\n\n\n\nstruct.unpack('!f', bytes.fromhex('41973333'))[0]\n\ns = '1f5a8444'\n\n# s = bytearray(s, encoding='utf-8')\n# s.reverse()\nb = [s[i:i+2] for i in range(0, len(s), 2)]\nb = ''.join(b[::-1])\n\"b:\",b\n\"bytes.fromhex(b):\", bytes.fromhex(b)\nstruct.unpack('!f', bytes.fromhex(b))[0]\n# s.reverse()\n# ss = struct.pack('&lt;I', s)\n\n# struct.unpack('!f', bytes.fromhex('1f5a8444'))[0]\n# s = s[::-1]\n# s\n# s = '44845a1f'\n# struct.unpack('!f', bytes.fromhex(s))[0]\n# struct.unpack('!f', bytes.fromhex('25ea8d44'))[0]\n# struct.unpack('!f', bytes.fromhex('f647d344'))[0]\n# struct.unpack('!f', bytes.fromhex('41995C29'))[0]\n\n18.899999618530273\n\n\n('b:', '44845a1f')\n\n\n('bytes.fromhex(b):', b'D\\x84Z\\x1f')\n\n\n1058.8162841796875\n\n\n\naddr_dec = int(xcp_data_list[0].address, 16)\naddr_dec\naddr_hex = hex(addr_dec)\naddr_hex\naddr_oct = oct(addr_dec)\nadd_dec_o = int(addr_oct,8)\nadd_dec_o\n\n1879091754\n\n\n'0x7000aa2a'\n\n\n1879091754\n\n\n\nxcp_data_list[0].__dict__\n# xcp_data[0].value_array_view\n# xcp_data[0].__dict__\n\n# f\"{xcp_data[0].value:.10s}...{xcp_data[0].value[-3:]}\"\n# xcp_data[0].value_array_view\n\n{'name': 'TQD_trqTrqSetNormal_MAP_v',\n 'address': '7000aa2a',\n 'dim': [21, 17],\n 'value_type': 'FLOAT32_IEEE',\n 'value_length': 4,\n 'value': '1f5a84441f5a84441f5a84441f5a84441f5a84441f5a84444ec38f44f1d9aa4494f0c5443707e14496d40445902519458a762d457f18564573ba7e45d79f8a45d79f8a4576288c42972d1843f3466a43057ee14349ec26448f195d446aa389440dbaa444b0d0bf4453e7da44a4c401459e15164599662a458d08534582aa7b450e768d450e768d4508324ac5f4d0bcc4381156432863d743dade2144200c5844b31c87445633a244f949bd449c60d8444881004543d214453d23294531c5514526677a459ab38e459ab38e4508e449c58f07c4c4118fbb4229579a4347e50244f99e3844ab586e442f09924408e6ac44e1c2c744270ef044b62c0c45595220459f9d4845e4e87045d79f8a45d79f8a45008149c5bf6002c5f6016dc43dfc3d435b8ac9434c0b1a446b514f44c54b8244d4ee9c44e391b7447a86df4488bd0345d4b717456bac3f4502a16745ccca8745d79f8a45f10849c5b2ed02c5d14973c49f8c14433d04b34316e10d440c404244039f7644fd7e954479aeaf44b2f5d644eb3cfe4412c212454b093a4584506145df4b8445d79f8a45da7b48c5f35c03c535f878c4201bdc4267f69d4303730244d2ea3544a1626944386d8e442029a844fcc2ce44d75cf54459fb0d4535953445102f5b4576e48045d79f8a45bbd947c5459011c5a08db6c46af513c4d7608a432782ef43bb512a4463e25c4485b98744d901a14457eec644d5daec44a963094527502f45a53c554523297b45d79f8a45942247c5d39711c5231ab8c43f091ac41f8770439096db43c8741f44481e5144e4638144a4389a44c577bf44e5b6e44402fb0445233a2a4543794f4563b87445dff58545665646c5338511c5ff67b9c4318b1fc470e64e435584c843b9ca144448534544d7db7544333293449e98b74409ffdb44ba3200452599244590ff4845fb656d45446c7145317545c56b5511c54b6bbac4815724c4549e3043651eb743d0f60a446d5e3a440ac66944d4968c448a24b04440b2d344f63ff744b12d1f4567bb4245dc916245dc916245f37e44c50b0319c5440edbc4731684c4877ab4c3be64a7430bf90144b73f304462865e4487668644881ba94489d0cb448a85ee44c6f71945c7ac3c45646b5345646b5345ae7343c5298718c54735dbc43d5c85c4c90cbec361579943d6a2f34325f72644e01c54444da18044997da244e559c4443036e64464f7144594b6354594b6354594b63545615342c59cf617c5ad33dbc4227a86c45c02c7c3cfe38b437eabe14397b91b446e9d46444581714484eb98446616b9444741d94485cb0c459ab325459ab325459ab325450d1e41c5074417c501d4dac4f41f87c49eafcdc3942081437d64d24333d4114428763a441c18634485059044fd7eae4474f8cc44b2f50445296f23453d2827453d282745b1d33fc58e6f16c5d616dac4914e87c42e19d2c3cf0f7243e3e0c443ef5c08446d492e44eb355444548c8644b2fda244116fbf44cd51f844d54d1845d54d1845d54d18454d743ec5cdd31ac59966eec49825a7c42fc93fc4ba1c45c3a575ba43da710044e1a82344e8df464473b27b447f429844c4abb2444f7ee7446d7309456d7309456d730945e1ff3cc582c419c54712edc4899ba6c4964940c46a704dc3c222b343e325f44382941a4412163b446bd86b44624d8e448eaea644e770d7445278024552780245527802456e763bc5309318c5e35febc46799a5c4d4a53fc46e6350c33be8ae436e80ea43510c13446bd83044918a5d445c1e85446f779b449629c844bcdbf4444e1bf8444e1bf844f3d739c5d53f17c56e4fe9c4311fa4c4eadd3dc4c5f54dc30fc6ad4355f3e3434e100d44f1262844e5c85044da6a7944670691445ca8b944504ae2448f52e4448f52e444712438c5d5d319c57206f7c43a65bac404887bc4944502c4403210c2977ee04378a00844a40121446793454429256a44765b874438edab44fb7ed0448f52e4448f52e444',\n 'type_size': 4,\n 'value_bytes': b'\\x1fZ\\x84D\\x1fZ\\x84D\\x1fZ\\x84D\\x1fZ\\x84D\\x1fZ\\x84D\\x1fZ\\x84DN\\xc3\\x8fD\\xf1\\xd9\\xaaD\\x94\\xf0\\xc5D7\\x07\\xe1D\\x96\\xd4\\x04E\\x90%\\x19E\\x8av-E\\x7f\\x18VEs\\xba~E\\xd7\\x9f\\x8aE\\xd7\\x9f\\x8aEv(\\x8cB\\x97-\\x18C\\xf3FjC\\x05~\\xe1CI\\xec&D\\x8f\\x19]Dj\\xa3\\x89D\\r\\xba\\xa4D\\xb0\\xd0\\xbfDS\\xe7\\xdaD\\xa4\\xc4\\x01E\\x9e\\x15\\x16E\\x99f*E\\x8d\\x08SE\\x82\\xaa{E\\x0ev\\x8dE\\x0ev\\x8dE\\x082J\\xc5\\xf4\\xd0\\xbc\\xc48\\x11VC(c\\xd7C\\xda\\xde!D \\x0cXD\\xb3\\x1c\\x87DV3\\xa2D\\xf9I\\xbdD\\x9c`\\xd8DH\\x81\\x00EC\\xd2\\x14E=#)E1\\xc5QE&gzE\\x9a\\xb3\\x8eE\\x9a\\xb3\\x8eE\\x08\\xe4I\\xc5\\x8f\\x07\\xc4\\xc4\\x11\\x8f\\xbbB)W\\x9aCG\\xe5\\x02D\\xf9\\x9e8D\\xabXnD/\\t\\x92D\\x08\\xe6\\xacD\\xe1\\xc2\\xc7D\\'\\x0e\\xf0D\\xb6,\\x0cEYR E\\x9f\\x9dHE\\xe4\\xe8pE\\xd7\\x9f\\x8aE\\xd7\\x9f\\x8aE\\x00\\x81I\\xc5\\xbf`\\x02\\xc5\\xf6\\x01m\\xc4=\\xfc=C[\\x8a\\xc9CL\\x0b\\x1aDkQOD\\xc5K\\x82D\\xd4\\xee\\x9cD\\xe3\\x91\\xb7Dz\\x86\\xdfD\\x88\\xbd\\x03E\\xd4\\xb7\\x17Ek\\xac?E\\x02\\xa1gE\\xcc\\xca\\x87E\\xd7\\x9f\\x8aE\\xf1\\x08I\\xc5\\xb2\\xed\\x02\\xc5\\xd1Is\\xc4\\x9f\\x8c\\x14C=\\x04\\xb3C\\x16\\xe1\\rD\\x0c@BD\\x03\\x9fvD\\xfd~\\x95Dy\\xae\\xafD\\xb2\\xf5\\xd6D\\xeb&lt;\\xfeD\\x12\\xc2\\x12EK\\t:E\\x84PaE\\xdfK\\x84E\\xd7\\x9f\\x8aE\\xda{H\\xc5\\xf3\\\\\\x03\\xc55\\xf8x\\xc4 \\x1b\\xdcBg\\xf6\\x9dC\\x03s\\x02D\\xd2\\xea5D\\xa1biD8m\\x8eD )\\xa8D\\xfc\\xc2\\xceD\\xd7\\\\\\xf5DY\\xfb\\rE5\\x954E\\x10/[Ev\\xe4\\x80E\\xd7\\x9f\\x8aE\\xbb\\xd9G\\xc5E\\x90\\x11\\xc5\\xa0\\x8d\\xb6\\xc4j\\xf5\\x13\\xc4\\xd7`\\x8aC\\'\\x82\\xefC\\xbbQ*Dc\\xe2\\\\D\\x85\\xb9\\x87D\\xd9\\x01\\xa1DW\\xee\\xc6D\\xd5\\xda\\xecD\\xa9c\\tE\\'P/E\\xa5&lt;UE#){E\\xd7\\x9f\\x8aE\\x94\"G\\xc5\\xd3\\x97\\x11\\xc5#\\x1a\\xb8\\xc4?\\t\\x1a\\xc4\\x1f\\x87pC\\x90\\x96\\xdbC\\xc8t\\x1fDH\\x1eQD\\xe4c\\x81D\\xa48\\x9aD\\xc5w\\xbfD\\xe5\\xb6\\xe4D\\x02\\xfb\\x04E#:*ECyOEc\\xb8tE\\xdf\\xf5\\x85EfVF\\xc53\\x85\\x11\\xc5\\xffg\\xb9\\xc41\\x8b\\x1f\\xc4p\\xe6NCU\\x84\\xc8C\\xb9\\xca\\x14DHSED\\xd7\\xdbuD32\\x93D\\x9e\\x98\\xb7D\\t\\xff\\xdbD\\xba2\\x00E%\\x99$E\\x90\\xffHE\\xfbemEDlqE1uE\\xc5kU\\x11\\xc5Kk\\xba\\xc4\\x81W$\\xc4T\\x9e0Ce\\x1e\\xb7C\\xd0\\xf6\\nDm^:D\\n\\xc6iD\\xd4\\x96\\x8cD\\x8a$\\xb0D@\\xb2\\xd3D\\xf6?\\xf7D\\xb1-\\x1fEg\\xbbBE\\xdc\\x91bE\\xdc\\x91bE\\xf3~D\\xc5\\x0b\\x03\\x19\\xc5D\\x0e\\xdb\\xc4s\\x16\\x84\\xc4\\x87z\\xb4\\xc3\\xbed\\xa7C\\x0b\\xf9\\x01D\\xb7?0Db\\x86^D\\x87f\\x86D\\x88\\x1b\\xa9D\\x89\\xd0\\xcbD\\x8a\\x85\\xeeD\\xc6\\xf7\\x19E\\xc7\\xac&lt;EdkSEdkSE\\xaesC\\xc5)\\x87\\x18\\xc5G5\\xdb\\xc4=\\\\\\x85\\xc4\\xc9\\x0c\\xbe\\xc3aW\\x99C\\xd6\\xa2\\xf3C%\\xf7&D\\xe0\\x1cTDM\\xa1\\x80D\\x99}\\xa2D\\xe5Y\\xc4D06\\xe6Dd\\xf7\\x14E\\x94\\xb65E\\x94\\xb65E\\x94\\xb65EaSB\\xc5\\x9c\\xf6\\x17\\xc5\\xad3\\xdb\\xc4\"z\\x86\\xc4\\\\\\x02\\xc7\\xc3\\xcf\\xe3\\x8bC~\\xab\\xe1C\\x97\\xb9\\x1bDn\\x9dFDE\\x81qD\\x84\\xeb\\x98Df\\x16\\xb9DGA\\xd9D\\x85\\xcb\\x0cE\\x9a\\xb3%E\\x9a\\xb3%E\\x9a\\xb3%E\\r\\x1eA\\xc5\\x07D\\x17\\xc5\\x01\\xd4\\xda\\xc4\\xf4\\x1f\\x87\\xc4\\x9e\\xaf\\xcd\\xc3\\x94 \\x81C}d\\xd2C3\\xd4\\x11D(v:D\\x1c\\x18cD\\x85\\x05\\x90D\\xfd~\\xaeDt\\xf8\\xccD\\xb2\\xf5\\x04E)o#E=(\\'E=(\\'E\\xb1\\xd3?\\xc5\\x8eo\\x16\\xc5\\xd6\\x16\\xda\\xc4\\x91N\\x87\\xc4.\\x19\\xd2\\xc3\\xcf\\x0frC\\xe3\\xe0\\xc4C\\xef\\\\\\x08DmI.D\\xeb5TDT\\x8c\\x86D\\xb2\\xfd\\xa2D\\x11o\\xbfD\\xcdQ\\xf8D\\xd5M\\x18E\\xd5M\\x18E\\xd5M\\x18EMt&gt;\\xc5\\xcd\\xd3\\x1a\\xc5\\x99f\\xee\\xc4\\x98%\\xa7\\xc4/\\xc9?\\xc4\\xba\\x1cE\\xc3\\xa5u\\xbaC\\xdaq\\x00D\\xe1\\xa8#D\\xe8\\xdfFDs\\xb2{D\\x7fB\\x98D\\xc4\\xab\\xb2DO~\\xe7Dms\\tEms\\tEms\\tE\\xe1\\xff&lt;\\xc5\\x82\\xc4\\x19\\xc5G\\x12\\xed\\xc4\\x89\\x9b\\xa6\\xc4\\x96I@\\xc4jpM\\xc3\\xc2\"\\xb3C\\xe3%\\xf4C\\x82\\x94\\x1aD\\x12\\x16;Dk\\xd8kDbM\\x8eD\\x8e\\xae\\xa6D\\xe7p\\xd7DRx\\x02ERx\\x02ERx\\x02Env;\\xc50\\x93\\x18\\xc5\\xe3_\\xeb\\xc4g\\x99\\xa5\\xc4\\xd4\\xa5?\\xc4ncP\\xc3;\\xe8\\xaeCn\\x80\\xeaCQ\\x0c\\x13Dk\\xd80D\\x91\\x8a]D\\\\\\x1e\\x85Dow\\x9bD\\x96)\\xc8D\\xbc\\xdb\\xf4DN\\x1b\\xf8DN\\x1b\\xf8D\\xf3\\xd79\\xc5\\xd5?\\x17\\xc5nO\\xe9\\xc41\\x1f\\xa4\\xc4\\xea\\xdd=\\xc4\\xc5\\xf5M\\xc3\\x0f\\xc6\\xadCU\\xf3\\xe3CN\\x10\\rD\\xf1&(D\\xe5\\xc8PD\\xdajyDg\\x06\\x91D\\\\\\xa8\\xb9DPJ\\xe2D\\x8fR\\xe4D\\x8fR\\xe4Dq$8\\xc5\\xd5\\xd3\\x19\\xc5r\\x06\\xf7\\xc4:e\\xba\\xc4\\x04\\x88{\\xc4\\x94E\\x02\\xc4@2\\x10\\xc2\\x97~\\xe0Cx\\xa0\\x08D\\xa4\\x01!Dg\\x93ED)%jDv[\\x87D8\\xed\\xabD\\xfb~\\xd0D\\x8fR\\xe4D\\x8fR\\xe4D',\n 'value_array_view': array([[ 1058.816,  1058.816,  1058.816, ...,  4075.653,  4435.98 ,\n          4435.98 ],\n        [   70.079,   152.178,   234.277, ...,  4026.657,  4526.757,\n          4526.757],\n        [-3235.127, -1510.53 ,   214.067, ...,  4006.447,  4566.45 ,\n          4566.45 ],\n        ...,\n        [-2999.402, -2441.199, -1882.996, ...,  1958.867,  1984.853,\n          1984.853],\n        [-2973.497, -2419.99 , -1866.482, ...,  1810.322,  1826.58 ,\n          1826.58 ],\n        [-2946.278, -2461.24 , -1976.201, ...,  1667.968,  1826.58 ,\n          1826.58 ]], dtype=float32)}\n\n\n\n# xcp_data[0].value_array_view\nxcp_data_list[0]\nxcp_data_list[0].__dict__\nxcp_data_list[0].model_dump()\n\ntest_eq(xcp_data_list[0].value_array_view.tobytes(), xcp_data_list[0].value_bytes)\n\n{   'address': '7000aa2a',\n    'dim': [21, 17],\n    'name': 'TQD_trqTrqSetNormal_MAP_v',\n    'type_size': 4,\n    'value': '1f5a84441f...444',\n    'value_array_view': array([[ 1058.816,  1058.816,  1058.816, ...,  4075.653,  4435.98 ,\n         4435.98 ],\n       [   70.079,   152.178,   234.277, ...,  4026.657,  4526.757,\n         4526.757],\n       [-3235.127, -1510.53 ,   214.067, ...,  4006.447,  4566.45 ,\n         4566.45 ],\n       ...,\n       [-2999.402, -2441.199, -1882.996, ...,  1958.867,  1984.853,\n         1984.853],\n       [-2973.497, -2419.99 , -1866.482, ...,  1810.322,  1826.58 ,\n         1826.58 ],\n       [-2946.278, -2461.24 , -1976.201, ...,  1667.968,  1826.58 ,\n         1826.58 ]], dtype=float32),\n    'value_bytes': \"b'\\\\x1f'...b'D'\",\n    'value_length': 4,\n    'value_type': 'FLOAT32_IEEE'}\n\n\n{'name': 'TQD_trqTrqSetNormal_MAP_v',\n 'address': '7000aa2a',\n 'dim': [21, 17],\n 'value_type': 'FLOAT32_IEEE',\n 'value_length': 4,\n 'value': '1f5a84441f5a84441f5a84441f5a84441f5a84441f5a84444ec38f44f1d9aa4494f0c5443707e14496d40445902519458a762d457f18564573ba7e45d79f8a45d79f8a4576288c42972d1843f3466a43057ee14349ec26448f195d446aa389440dbaa444b0d0bf4453e7da44a4c401459e15164599662a458d08534582aa7b450e768d450e768d4508324ac5f4d0bcc4381156432863d743dade2144200c5844b31c87445633a244f949bd449c60d8444881004543d214453d23294531c5514526677a459ab38e459ab38e4508e449c58f07c4c4118fbb4229579a4347e50244f99e3844ab586e442f09924408e6ac44e1c2c744270ef044b62c0c45595220459f9d4845e4e87045d79f8a45d79f8a45008149c5bf6002c5f6016dc43dfc3d435b8ac9434c0b1a446b514f44c54b8244d4ee9c44e391b7447a86df4488bd0345d4b717456bac3f4502a16745ccca8745d79f8a45f10849c5b2ed02c5d14973c49f8c14433d04b34316e10d440c404244039f7644fd7e954479aeaf44b2f5d644eb3cfe4412c212454b093a4584506145df4b8445d79f8a45da7b48c5f35c03c535f878c4201bdc4267f69d4303730244d2ea3544a1626944386d8e442029a844fcc2ce44d75cf54459fb0d4535953445102f5b4576e48045d79f8a45bbd947c5459011c5a08db6c46af513c4d7608a432782ef43bb512a4463e25c4485b98744d901a14457eec644d5daec44a963094527502f45a53c554523297b45d79f8a45942247c5d39711c5231ab8c43f091ac41f8770439096db43c8741f44481e5144e4638144a4389a44c577bf44e5b6e44402fb0445233a2a4543794f4563b87445dff58545665646c5338511c5ff67b9c4318b1fc470e64e435584c843b9ca144448534544d7db7544333293449e98b74409ffdb44ba3200452599244590ff4845fb656d45446c7145317545c56b5511c54b6bbac4815724c4549e3043651eb743d0f60a446d5e3a440ac66944d4968c448a24b04440b2d344f63ff744b12d1f4567bb4245dc916245dc916245f37e44c50b0319c5440edbc4731684c4877ab4c3be64a7430bf90144b73f304462865e4487668644881ba94489d0cb448a85ee44c6f71945c7ac3c45646b5345646b5345ae7343c5298718c54735dbc43d5c85c4c90cbec361579943d6a2f34325f72644e01c54444da18044997da244e559c4443036e64464f7144594b6354594b6354594b63545615342c59cf617c5ad33dbc4227a86c45c02c7c3cfe38b437eabe14397b91b446e9d46444581714484eb98446616b9444741d94485cb0c459ab325459ab325459ab325450d1e41c5074417c501d4dac4f41f87c49eafcdc3942081437d64d24333d4114428763a441c18634485059044fd7eae4474f8cc44b2f50445296f23453d2827453d282745b1d33fc58e6f16c5d616dac4914e87c42e19d2c3cf0f7243e3e0c443ef5c08446d492e44eb355444548c8644b2fda244116fbf44cd51f844d54d1845d54d1845d54d18454d743ec5cdd31ac59966eec49825a7c42fc93fc4ba1c45c3a575ba43da710044e1a82344e8df464473b27b447f429844c4abb2444f7ee7446d7309456d7309456d730945e1ff3cc582c419c54712edc4899ba6c4964940c46a704dc3c222b343e325f44382941a4412163b446bd86b44624d8e448eaea644e770d7445278024552780245527802456e763bc5309318c5e35febc46799a5c4d4a53fc46e6350c33be8ae436e80ea43510c13446bd83044918a5d445c1e85446f779b449629c844bcdbf4444e1bf8444e1bf844f3d739c5d53f17c56e4fe9c4311fa4c4eadd3dc4c5f54dc30fc6ad4355f3e3434e100d44f1262844e5c85044da6a7944670691445ca8b944504ae2448f52e4448f52e444712438c5d5d319c57206f7c43a65bac404887bc4944502c4403210c2977ee04378a00844a40121446793454429256a44765b874438edab44fb7ed0448f52e4448f52e444',\n 'type_size': 4,\n 'value_bytes': b'\\x1fZ\\x84D\\x1fZ\\x84D\\x1fZ\\x84D\\x1fZ\\x84D\\x1fZ\\x84D\\x1fZ\\x84DN\\xc3\\x8fD\\xf1\\xd9\\xaaD\\x94\\xf0\\xc5D7\\x07\\xe1D\\x96\\xd4\\x04E\\x90%\\x19E\\x8av-E\\x7f\\x18VEs\\xba~E\\xd7\\x9f\\x8aE\\xd7\\x9f\\x8aEv(\\x8cB\\x97-\\x18C\\xf3FjC\\x05~\\xe1CI\\xec&D\\x8f\\x19]Dj\\xa3\\x89D\\r\\xba\\xa4D\\xb0\\xd0\\xbfDS\\xe7\\xdaD\\xa4\\xc4\\x01E\\x9e\\x15\\x16E\\x99f*E\\x8d\\x08SE\\x82\\xaa{E\\x0ev\\x8dE\\x0ev\\x8dE\\x082J\\xc5\\xf4\\xd0\\xbc\\xc48\\x11VC(c\\xd7C\\xda\\xde!D \\x0cXD\\xb3\\x1c\\x87DV3\\xa2D\\xf9I\\xbdD\\x9c`\\xd8DH\\x81\\x00EC\\xd2\\x14E=#)E1\\xc5QE&gzE\\x9a\\xb3\\x8eE\\x9a\\xb3\\x8eE\\x08\\xe4I\\xc5\\x8f\\x07\\xc4\\xc4\\x11\\x8f\\xbbB)W\\x9aCG\\xe5\\x02D\\xf9\\x9e8D\\xabXnD/\\t\\x92D\\x08\\xe6\\xacD\\xe1\\xc2\\xc7D\\'\\x0e\\xf0D\\xb6,\\x0cEYR E\\x9f\\x9dHE\\xe4\\xe8pE\\xd7\\x9f\\x8aE\\xd7\\x9f\\x8aE\\x00\\x81I\\xc5\\xbf`\\x02\\xc5\\xf6\\x01m\\xc4=\\xfc=C[\\x8a\\xc9CL\\x0b\\x1aDkQOD\\xc5K\\x82D\\xd4\\xee\\x9cD\\xe3\\x91\\xb7Dz\\x86\\xdfD\\x88\\xbd\\x03E\\xd4\\xb7\\x17Ek\\xac?E\\x02\\xa1gE\\xcc\\xca\\x87E\\xd7\\x9f\\x8aE\\xf1\\x08I\\xc5\\xb2\\xed\\x02\\xc5\\xd1Is\\xc4\\x9f\\x8c\\x14C=\\x04\\xb3C\\x16\\xe1\\rD\\x0c@BD\\x03\\x9fvD\\xfd~\\x95Dy\\xae\\xafD\\xb2\\xf5\\xd6D\\xeb&lt;\\xfeD\\x12\\xc2\\x12EK\\t:E\\x84PaE\\xdfK\\x84E\\xd7\\x9f\\x8aE\\xda{H\\xc5\\xf3\\\\\\x03\\xc55\\xf8x\\xc4 \\x1b\\xdcBg\\xf6\\x9dC\\x03s\\x02D\\xd2\\xea5D\\xa1biD8m\\x8eD )\\xa8D\\xfc\\xc2\\xceD\\xd7\\\\\\xf5DY\\xfb\\rE5\\x954E\\x10/[Ev\\xe4\\x80E\\xd7\\x9f\\x8aE\\xbb\\xd9G\\xc5E\\x90\\x11\\xc5\\xa0\\x8d\\xb6\\xc4j\\xf5\\x13\\xc4\\xd7`\\x8aC\\'\\x82\\xefC\\xbbQ*Dc\\xe2\\\\D\\x85\\xb9\\x87D\\xd9\\x01\\xa1DW\\xee\\xc6D\\xd5\\xda\\xecD\\xa9c\\tE\\'P/E\\xa5&lt;UE#){E\\xd7\\x9f\\x8aE\\x94\"G\\xc5\\xd3\\x97\\x11\\xc5#\\x1a\\xb8\\xc4?\\t\\x1a\\xc4\\x1f\\x87pC\\x90\\x96\\xdbC\\xc8t\\x1fDH\\x1eQD\\xe4c\\x81D\\xa48\\x9aD\\xc5w\\xbfD\\xe5\\xb6\\xe4D\\x02\\xfb\\x04E#:*ECyOEc\\xb8tE\\xdf\\xf5\\x85EfVF\\xc53\\x85\\x11\\xc5\\xffg\\xb9\\xc41\\x8b\\x1f\\xc4p\\xe6NCU\\x84\\xc8C\\xb9\\xca\\x14DHSED\\xd7\\xdbuD32\\x93D\\x9e\\x98\\xb7D\\t\\xff\\xdbD\\xba2\\x00E%\\x99$E\\x90\\xffHE\\xfbemEDlqE1uE\\xc5kU\\x11\\xc5Kk\\xba\\xc4\\x81W$\\xc4T\\x9e0Ce\\x1e\\xb7C\\xd0\\xf6\\nDm^:D\\n\\xc6iD\\xd4\\x96\\x8cD\\x8a$\\xb0D@\\xb2\\xd3D\\xf6?\\xf7D\\xb1-\\x1fEg\\xbbBE\\xdc\\x91bE\\xdc\\x91bE\\xf3~D\\xc5\\x0b\\x03\\x19\\xc5D\\x0e\\xdb\\xc4s\\x16\\x84\\xc4\\x87z\\xb4\\xc3\\xbed\\xa7C\\x0b\\xf9\\x01D\\xb7?0Db\\x86^D\\x87f\\x86D\\x88\\x1b\\xa9D\\x89\\xd0\\xcbD\\x8a\\x85\\xeeD\\xc6\\xf7\\x19E\\xc7\\xac&lt;EdkSEdkSE\\xaesC\\xc5)\\x87\\x18\\xc5G5\\xdb\\xc4=\\\\\\x85\\xc4\\xc9\\x0c\\xbe\\xc3aW\\x99C\\xd6\\xa2\\xf3C%\\xf7&D\\xe0\\x1cTDM\\xa1\\x80D\\x99}\\xa2D\\xe5Y\\xc4D06\\xe6Dd\\xf7\\x14E\\x94\\xb65E\\x94\\xb65E\\x94\\xb65EaSB\\xc5\\x9c\\xf6\\x17\\xc5\\xad3\\xdb\\xc4\"z\\x86\\xc4\\\\\\x02\\xc7\\xc3\\xcf\\xe3\\x8bC~\\xab\\xe1C\\x97\\xb9\\x1bDn\\x9dFDE\\x81qD\\x84\\xeb\\x98Df\\x16\\xb9DGA\\xd9D\\x85\\xcb\\x0cE\\x9a\\xb3%E\\x9a\\xb3%E\\x9a\\xb3%E\\r\\x1eA\\xc5\\x07D\\x17\\xc5\\x01\\xd4\\xda\\xc4\\xf4\\x1f\\x87\\xc4\\x9e\\xaf\\xcd\\xc3\\x94 \\x81C}d\\xd2C3\\xd4\\x11D(v:D\\x1c\\x18cD\\x85\\x05\\x90D\\xfd~\\xaeDt\\xf8\\xccD\\xb2\\xf5\\x04E)o#E=(\\'E=(\\'E\\xb1\\xd3?\\xc5\\x8eo\\x16\\xc5\\xd6\\x16\\xda\\xc4\\x91N\\x87\\xc4.\\x19\\xd2\\xc3\\xcf\\x0frC\\xe3\\xe0\\xc4C\\xef\\\\\\x08DmI.D\\xeb5TDT\\x8c\\x86D\\xb2\\xfd\\xa2D\\x11o\\xbfD\\xcdQ\\xf8D\\xd5M\\x18E\\xd5M\\x18E\\xd5M\\x18EMt&gt;\\xc5\\xcd\\xd3\\x1a\\xc5\\x99f\\xee\\xc4\\x98%\\xa7\\xc4/\\xc9?\\xc4\\xba\\x1cE\\xc3\\xa5u\\xbaC\\xdaq\\x00D\\xe1\\xa8#D\\xe8\\xdfFDs\\xb2{D\\x7fB\\x98D\\xc4\\xab\\xb2DO~\\xe7Dms\\tEms\\tEms\\tE\\xe1\\xff&lt;\\xc5\\x82\\xc4\\x19\\xc5G\\x12\\xed\\xc4\\x89\\x9b\\xa6\\xc4\\x96I@\\xc4jpM\\xc3\\xc2\"\\xb3C\\xe3%\\xf4C\\x82\\x94\\x1aD\\x12\\x16;Dk\\xd8kDbM\\x8eD\\x8e\\xae\\xa6D\\xe7p\\xd7DRx\\x02ERx\\x02ERx\\x02Env;\\xc50\\x93\\x18\\xc5\\xe3_\\xeb\\xc4g\\x99\\xa5\\xc4\\xd4\\xa5?\\xc4ncP\\xc3;\\xe8\\xaeCn\\x80\\xeaCQ\\x0c\\x13Dk\\xd80D\\x91\\x8a]D\\\\\\x1e\\x85Dow\\x9bD\\x96)\\xc8D\\xbc\\xdb\\xf4DN\\x1b\\xf8DN\\x1b\\xf8D\\xf3\\xd79\\xc5\\xd5?\\x17\\xc5nO\\xe9\\xc41\\x1f\\xa4\\xc4\\xea\\xdd=\\xc4\\xc5\\xf5M\\xc3\\x0f\\xc6\\xadCU\\xf3\\xe3CN\\x10\\rD\\xf1&(D\\xe5\\xc8PD\\xdajyDg\\x06\\x91D\\\\\\xa8\\xb9DPJ\\xe2D\\x8fR\\xe4D\\x8fR\\xe4Dq$8\\xc5\\xd5\\xd3\\x19\\xc5r\\x06\\xf7\\xc4:e\\xba\\xc4\\x04\\x88{\\xc4\\x94E\\x02\\xc4@2\\x10\\xc2\\x97~\\xe0Cx\\xa0\\x08D\\xa4\\x01!Dg\\x93ED)%jDv[\\x87D8\\xed\\xabD\\xfb~\\xd0D\\x8fR\\xe4D\\x8fR\\xe4D',\n 'value_array_view': array([[ 1058.816,  1058.816,  1058.816, ...,  4075.653,  4435.98 ,\n          4435.98 ],\n        [   70.079,   152.178,   234.277, ...,  4026.657,  4526.757,\n          4526.757],\n        [-3235.127, -1510.53 ,   214.067, ...,  4006.447,  4566.45 ,\n          4566.45 ],\n        ...,\n        [-2999.402, -2441.199, -1882.996, ...,  1958.867,  1984.853,\n          1984.853],\n        [-2973.497, -2419.99 , -1866.482, ...,  1810.322,  1826.58 ,\n          1826.58 ],\n        [-2946.278, -2461.24 , -1976.201, ...,  1667.968,  1826.58 ,\n          1826.58 ]], dtype=float32)}\n\n\n{'name': 'TQD_trqTrqSetNormal_MAP_v',\n 'address': '7000aa2a',\n 'dim': [21, 17],\n 'value_type': 'FLOAT32_IEEE',\n 'value_length': 4,\n 'value': '1f5a84441f5a84441f5a84441f5a84441f5a84441f5a84444ec38f44f1d9aa4494f0c5443707e14496d40445902519458a762d457f18564573ba7e45d79f8a45d79f8a4576288c42972d1843f3466a43057ee14349ec26448f195d446aa389440dbaa444b0d0bf4453e7da44a4c401459e15164599662a458d08534582aa7b450e768d450e768d4508324ac5f4d0bcc4381156432863d743dade2144200c5844b31c87445633a244f949bd449c60d8444881004543d214453d23294531c5514526677a459ab38e459ab38e4508e449c58f07c4c4118fbb4229579a4347e50244f99e3844ab586e442f09924408e6ac44e1c2c744270ef044b62c0c45595220459f9d4845e4e87045d79f8a45d79f8a45008149c5bf6002c5f6016dc43dfc3d435b8ac9434c0b1a446b514f44c54b8244d4ee9c44e391b7447a86df4488bd0345d4b717456bac3f4502a16745ccca8745d79f8a45f10849c5b2ed02c5d14973c49f8c14433d04b34316e10d440c404244039f7644fd7e954479aeaf44b2f5d644eb3cfe4412c212454b093a4584506145df4b8445d79f8a45da7b48c5f35c03c535f878c4201bdc4267f69d4303730244d2ea3544a1626944386d8e442029a844fcc2ce44d75cf54459fb0d4535953445102f5b4576e48045d79f8a45bbd947c5459011c5a08db6c46af513c4d7608a432782ef43bb512a4463e25c4485b98744d901a14457eec644d5daec44a963094527502f45a53c554523297b45d79f8a45942247c5d39711c5231ab8c43f091ac41f8770439096db43c8741f44481e5144e4638144a4389a44c577bf44e5b6e44402fb0445233a2a4543794f4563b87445dff58545665646c5338511c5ff67b9c4318b1fc470e64e435584c843b9ca144448534544d7db7544333293449e98b74409ffdb44ba3200452599244590ff4845fb656d45446c7145317545c56b5511c54b6bbac4815724c4549e3043651eb743d0f60a446d5e3a440ac66944d4968c448a24b04440b2d344f63ff744b12d1f4567bb4245dc916245dc916245f37e44c50b0319c5440edbc4731684c4877ab4c3be64a7430bf90144b73f304462865e4487668644881ba94489d0cb448a85ee44c6f71945c7ac3c45646b5345646b5345ae7343c5298718c54735dbc43d5c85c4c90cbec361579943d6a2f34325f72644e01c54444da18044997da244e559c4443036e64464f7144594b6354594b6354594b63545615342c59cf617c5ad33dbc4227a86c45c02c7c3cfe38b437eabe14397b91b446e9d46444581714484eb98446616b9444741d94485cb0c459ab325459ab325459ab325450d1e41c5074417c501d4dac4f41f87c49eafcdc3942081437d64d24333d4114428763a441c18634485059044fd7eae4474f8cc44b2f50445296f23453d2827453d282745b1d33fc58e6f16c5d616dac4914e87c42e19d2c3cf0f7243e3e0c443ef5c08446d492e44eb355444548c8644b2fda244116fbf44cd51f844d54d1845d54d1845d54d18454d743ec5cdd31ac59966eec49825a7c42fc93fc4ba1c45c3a575ba43da710044e1a82344e8df464473b27b447f429844c4abb2444f7ee7446d7309456d7309456d730945e1ff3cc582c419c54712edc4899ba6c4964940c46a704dc3c222b343e325f44382941a4412163b446bd86b44624d8e448eaea644e770d7445278024552780245527802456e763bc5309318c5e35febc46799a5c4d4a53fc46e6350c33be8ae436e80ea43510c13446bd83044918a5d445c1e85446f779b449629c844bcdbf4444e1bf8444e1bf844f3d739c5d53f17c56e4fe9c4311fa4c4eadd3dc4c5f54dc30fc6ad4355f3e3434e100d44f1262844e5c85044da6a7944670691445ca8b944504ae2448f52e4448f52e444712438c5d5d319c57206f7c43a65bac404887bc4944502c4403210c2977ee04378a00844a40121446793454429256a44765b874438edab44fb7ed0448f52e4448f52e444'}\n\n\n\nxcp_data = Get_Init_XCPData('../res/init_value_17rows_broken.json')\n# xcp_data[0], f'value byte length: {len(xcp_data[0].value)}'\n# xcp_data[1], f'value byte length: {len(xcp_data[1].value)}'\n\n1 validation error for XCPData\n  Value error, value length 2855!=(dimension [21, 17])*(value length 2856)! [type=value_error, input_value={'name': 'TQD_trqTrqSetNo...7ed0448f52e4448f52e444'}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.6/v/value_error\n1 validation error for XCPData\nvalue_type\n  Assertion failed, Invalid data type FLOAT32_IEEE1 [type=assertion_error, input_value='FLOAT32_IEEE1', input_type=str]\n    For further information visit https://errors.pydantic.dev/2.6/v/assertion_error\n1 validation error for XCPData\n  Value error, Value length 8 doesn't match data type FLOAT32_IEEE(4)! [type=value_error, input_value={'name': 'TQD_trqTrqSetEC...7ed0448f52e4448f52e444'}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.6/v/value_error\n\n\n\n\n\nXCPCalib\n\n XCPCalib (config:__main__.XCPConfig=None,\n           data:List[__main__.XCPData]=None)\n\nXCP calibration parameter\n\n\n\n\nType\nDetails\n\n\n\n\ndata\nAny\n\n\n\nReturns\nNone\ntype: ignore\n\n\n\n\n\n\nGet_XCPCalib_From_XCPJSon\n\n Get_XCPCalib_From_XCPJSon\n                            (path:pathlib.Path=Path('../res/download.json'\n                            ))\n\n\n\n\nGenerate_Init_XCPData_From_A2L\n\n Generate_Init_XCPData_From_A2L\n                                 (a2l:pathlib.Path=Path('../res/vbu_sample\n                                 .json'), keys:List[str]=['TQD_trqTrqSetNo\n                                 rmal_MAP_v',\n                                 'VBU_L045A_CWP_05_09T_AImode_CM_single',\n                                 'Lookup2D_FLOAT32_IEEE',\n                                 'Lookup2D_X_FLOAT32_IEEE, TQD_vVehSpd',\n                                 'TQD_vSgndSpd_MAP_y',\n                                 'TQD_pctAccPedPosFlt',\n                                 'TQD_pctAccPdl_MAP_x'],\n                                 node_path:str='/PROJECT/MODULE[]')\n\n*Generate XCP calibration header from A2L file and calibration parameter name\nArgs: a2l (Path): path to the A2L file keys (List[str]): calibration parameter name node_path (str): path to the calibration parameter in the A2L json file\nReturns: XCPCalib: XCP calibration parameter*\n\nargs.leaves, args.node_path\n\n(['TQD_trqTrqSetNormal_MAP_v',\n  'VBU_L045A_CWP_05_09T_AImode_CM_single',\n  'Lookup2D_FLOAT32_IEEE',\n  'Lookup2D_X_FLOAT32_IEEE',\n  'Scalar_FLOAT32_IEEE',\n  'TQD_vVehSpd',\n  'TQD_vSgndSpd_MAP_y',\n  'TQD_pctAccPedPosFlt',\n  'TQD_pctAccPdl_MAP_x'],\n '/PROJECT/MODULE[], ')\n\n\n\n# init_xcpdata = Get_Init_XCPData('../res/init_value_17rows.json')\ninit_xcp_calib = Get_XCPCalib_From_XCPJSon('../res/download.json')\ninit_xcp_calib.config\nlen(init_xcp_calib.data)\ninit_xcp_calib.data[0]\ntype(init_xcp_calib.data[0])\ninit_xcp_calib.model_dump()\ninit_xcp_calib.data[0].value_array_view.shape\n\nXCPConfig(channel=3, download_can_id=630, upload_can_id=631)\n\n\n1\n\n\n{   'address': '7000aa2a',\n    'dim': [14, 17],\n    'name': 'TQD_trqTrqSetNormal_MAP_v',\n    'type_size': 4,\n    'value': '0000000025...344',\n    'value_array_view': array([[    0.   ,  1135.317,  1135.317, ...,  4436.   ,  4436.   ,\n         4436.   ],\n       [    0.   ,   148.09 ,   148.09 , ...,  4436.   ,  4436.   ,\n         4436.   ],\n       [-1338.534,  -833.344,  -328.155, ...,  4436.   ,  4436.   ,\n         4436.   ],\n       ...,\n       [-1316.842, -1086.408,  -855.974, ...,  2034.368,  2034.368,\n         2034.368],\n       [-1141.171,  -926.042,  -710.912, ...,  1859.521,  1859.521,\n         1859.521],\n       [ -286.008,  -135.973,    14.062, ...,  1690.249,  1690.249,\n         1690.249]], dtype=float32),\n    'value_bytes': \"b'\\\\x00'...b'D'\",\n    'value_length': 4,\n    'value_type': 'FLOAT32_IEEE'}\n\n\n__main__.XCPData\n\n\n{'config': {'channel': 3, 'download_can_id': 630, 'upload_can_id': 631},\n 'data': [{'name': 'TQD_trqTrqSetNormal_MAP_v',\n   'address': '7000aa2a',\n   'dim': [14, 17],\n   'value_type': 'FLOAT32_IEEE',\n   'value_length': 4,\n   'value': '0000000025ea8d4425ea8d4425ea8d4425ea8d44db349544b31eb6448c08d74464f2f7441e6e0c45811d2545e3cc3d45467c564585ed834500a08a4500a08a4500a08a4500000000ed161443ed1614434eba8d431a791e44cb4c60443e10914417fab144efe3d244c8cdf34446961245a9452b450bf54345d053754500a08a4500a08a4500a08a451451a7c40b5650c4dd13a4c3b80831434da9f94356254144847c81445c66a2443550c3440d3ae44469cc0a45cb7b23452e2b3c45f3896d4500a08a4500a08a4500a08a45fffc0fc5a4fcd0c44bff81c4c807ccc339db5f4376a00944f8d74744bd0783447f23a244403fc144e2e8ef4442490f45139e2645b5475545abf8814500a08a4500a08a45771f0dc59f6adac451969ac4078435c4ab6d57c3629a9343eb8d18443f2953444ae28644f42fa4447424d044f318fc44b906144539fb3f45b8ef6b4500a08a4500a08a45483e09c51dd0dcc4a923a7c46cee62c40a2befc3dcc943c29338be43be142944e413604485898b44e1c8b4443e08de44cda303452ae32c4586225645e3617f4500a08a45735904c5aa24dac46c96abc45f107ac4e5f31cc4ac5d7fc37928ea4212c3f443ff0b3e44f76e7144b5419f44efcbc5442856ec444eb51c45873f4345c1c96945f1378345efe1fcc4bac2d3c485a3aac44f8481c434ca30c49117bdc3ddd544c21ae28b43782f1844d5ca5444823a8e44990fb244b0e4d5446fc70e45869c32459e715645d52c5745ab09efc4be0dcac4d111a5c4e31580c4eb3336c42178d8c3d81009c393ce1e43ff56e3435aa33b4499f082448d10a4448130c54435b8034529d8244576423545764235451a2adfc4846cbcc4eeae99c4b0e26dc4846728c4afd8c5c35b89ebc2032820435a0adb4359003344857b784494a89a446513b94408e9f544555f194515471e4515471e453c43cdc4c4f8acc44dae8cc4abc758c4bc3218c49b3bafc3f646b8c240302643fd41d443eeb52a44dc4a6b44cce696447b9cb244d807ea44ef260e45ef260e45ef260e45f49aa4c40fcd87c455fe55c48c621cc4868dc5c3e8ab24c3798683423019944361a803442a443d44f3df7644de3d98446b3eb144833fe344c44bfe44c44bfe44c44bfe447ba58ec4ae8267c466ba31c43ce4f7c3ac538cc3700c83c2e89a1543045eb6434af7104492bf4644da877c4411289944149ab444e730e144ab70e844ab70e844ab70e8440b018fc329f907c359fc6041b4182443d1109d434815e843e08c19441b0f3f4457916444c9098544e7ca9744058caa44224dbd44f647d344f647d344f647d344f647d344'}]}\n\n\n(14, 17)\n\n\n\n# xcp_data[0].name, xcp_data[0].dim, xcp_data[0].value_type, xcp_data[0].value_length, len(xcp_data[0].value)\nxcp_data = Generate_Init_XCPData_From_A2L(a2l=Path('../res/VBU_AI.json'),\n                            keys=args.leaves,\n                            node_path=args.node_path)\n\n\n# len(xcp_data.value)\nxcp_data.value  = 12\ntry:\n    XCPData.model_validate(xcp_data)\nexcept ValidationError as exc:\n    print(exc)\n\n1 validation error for XCPData\nvalue\n  Input should be a valid string [type=string_type, input_value=12, input_type=int]\n    For further information visit https://errors.pydantic.dev/2.6/v/string_type\n\n\n\nxcp_data.value = init_xcp_calib.data[0].value\nxcp_data\n# xcp_data.value_array_view\n\n{   'address': '7000aa2a',\n    'dim': [14, 17],\n    'name': 'TQD_trqTrqSetNormal_MAP_v',\n    'type_size': 4,\n    'value': '0000000025...344',\n    'value_array_view': array([[    0.   ,  1135.317,  1135.317, ...,  4436.   ,  4436.   ,\n         4436.   ],\n       [    0.   ,   148.09 ,   148.09 , ...,  4436.   ,  4436.   ,\n         4436.   ],\n       [-1338.534,  -833.344,  -328.155, ...,  4436.   ,  4436.   ,\n         4436.   ],\n       ...,\n       [-1316.842, -1086.408,  -855.974, ...,  2034.368,  2034.368,\n         2034.368],\n       [-1141.171,  -926.042,  -710.912, ...,  1859.521,  1859.521,\n         1859.521],\n       [ -286.008,  -135.973,    14.062, ...,  1690.249,  1690.249,\n         1690.249]], dtype=float32),\n    'value_bytes': \"b'\\\\x00'...b'D'\",\n    'value_length': 4,\n    'value_type': 'FLOAT32_IEEE'}\n\n\n\nxcp_calib = XCPCalib(config=XCPConfig(channel=3, download=630, upload=631),data=[xcp_data])\nxcp_calib.model_dump()\nxcp_calib\n\n{'config': {'channel': 3, 'download_can_id': 630, 'upload_can_id': 631},\n 'data': [{'name': 'TQD_trqTrqSetNormal_MAP_v',\n   'address': '7000aa2a',\n   'dim': [14, 17],\n   'value_type': 'FLOAT32_IEEE',\n   'value_length': 4,\n   'value': '0000000025ea8d4425ea8d4425ea8d4425ea8d44db349544b31eb6448c08d74464f2f7441e6e0c45811d2545e3cc3d45467c564585ed834500a08a4500a08a4500a08a4500000000ed161443ed1614434eba8d431a791e44cb4c60443e10914417fab144efe3d244c8cdf34446961245a9452b450bf54345d053754500a08a4500a08a4500a08a451451a7c40b5650c4dd13a4c3b80831434da9f94356254144847c81445c66a2443550c3440d3ae44469cc0a45cb7b23452e2b3c45f3896d4500a08a4500a08a4500a08a45fffc0fc5a4fcd0c44bff81c4c807ccc339db5f4376a00944f8d74744bd0783447f23a244403fc144e2e8ef4442490f45139e2645b5475545abf8814500a08a4500a08a45771f0dc59f6adac451969ac4078435c4ab6d57c3629a9343eb8d18443f2953444ae28644f42fa4447424d044f318fc44b906144539fb3f45b8ef6b4500a08a4500a08a45483e09c51dd0dcc4a923a7c46cee62c40a2befc3dcc943c29338be43be142944e413604485898b44e1c8b4443e08de44cda303452ae32c4586225645e3617f4500a08a45735904c5aa24dac46c96abc45f107ac4e5f31cc4ac5d7fc37928ea4212c3f443ff0b3e44f76e7144b5419f44efcbc5442856ec444eb51c45873f4345c1c96945f1378345efe1fcc4bac2d3c485a3aac44f8481c434ca30c49117bdc3ddd544c21ae28b43782f1844d5ca5444823a8e44990fb244b0e4d5446fc70e45869c32459e715645d52c5745ab09efc4be0dcac4d111a5c4e31580c4eb3336c42178d8c3d81009c393ce1e43ff56e3435aa33b4499f082448d10a4448130c54435b8034529d8244576423545764235451a2adfc4846cbcc4eeae99c4b0e26dc4846728c4afd8c5c35b89ebc2032820435a0adb4359003344857b784494a89a446513b94408e9f544555f194515471e4515471e453c43cdc4c4f8acc44dae8cc4abc758c4bc3218c49b3bafc3f646b8c240302643fd41d443eeb52a44dc4a6b44cce696447b9cb244d807ea44ef260e45ef260e45ef260e45f49aa4c40fcd87c455fe55c48c621cc4868dc5c3e8ab24c3798683423019944361a803442a443d44f3df7644de3d98446b3eb144833fe344c44bfe44c44bfe44c44bfe447ba58ec4ae8267c466ba31c43ce4f7c3ac538cc3700c83c2e89a1543045eb6434af7104492bf4644da877c4411289944149ab444e730e144ab70e844ab70e844ab70e8440b018fc329f907c359fc6041b4182443d1109d434815e843e08c19441b0f3f4457916444c9098544e7ca9744058caa44224dbd44f647d344f647d344f647d344f647d344'}]}\n\n\nXCPCalib(config=XCPConfig(channel=3, download_can_id=630, upload_can_id=631), data=[{   'address': '7000aa2a',\n    'dim': [14, 17],\n    'name': 'TQD_trqTrqSetNormal_MAP_v',\n    'type_size': 4,\n    'value': '0000000025...344',\n    'value_array_view': array([[    0.   ,  1135.317,  1135.317, ...,  4436.   ,  4436.   ,\n         4436.   ],\n       [    0.   ,   148.09 ,   148.09 , ...,  4436.   ,  4436.   ,\n         4436.   ],\n       [-1338.534,  -833.344,  -328.155, ...,  4436.   ,  4436.   ,\n         4436.   ],\n       ...,\n       [-1316.842, -1086.408,  -855.974, ...,  2034.368,  2034.368,\n         2034.368],\n       [-1141.171,  -926.042,  -710.912, ...,  1859.521,  1859.521,\n         1859.521],\n       [ -286.008,  -135.973,    14.062, ...,  1690.249,  1690.249,\n         1690.249]], dtype=float32),\n    'value_bytes': \"b'\\\\x00'...b'D'\",\n    'value_length': 4,\n    'value_type': 'FLOAT32_IEEE'}])\n\n\n\nRecord.record_registry\n\n{'Calibration.TQD_trqTrqSetNormal_MAP_v': &lt;Calibration: 'TQD_trqTrqSetNormal_MAP_v'&gt;,\n 'Measurement.TQD_vVehSpd': &lt;Measurement: 'TQD_vVehSpd'&gt;,\n 'Measurement.TQD_pctAccPedPosFlt': &lt;Measurement: 'TQD_pctAccPedPosFlt'&gt;,\n 'AxisScale.TQD_vSgndSpd_MAP_y': &lt;AxisScale: 'TQD_vSgndSpd_MAP_y'&gt;,\n 'AxisScale.TQD_pctAccPdl_MAP_x': &lt;AxisScale: 'TQD_pctAccPdl_MAP_x'&gt;,\n 'DataConversion.VBU_L045A_CWP_05_09T_AImode_CM_single': &lt;DataConversion: 'VBU_L045A_CWP_05_09T_AImode_CM_single'&gt;,\n 'DataLayout.Scalar_FLOAT32_IEEE': &lt;DataLayout: 'Scalar_FLOAT32_IEEE'&gt;,\n 'DataLayout.Lookup2D_FLOAT32_IEEE': &lt;DataLayout: 'Lookup2D_FLOAT32_IEEE'&gt;,\n 'DataLayout.Lookup2D_X_FLOAT32_IEEE': &lt;DataLayout: 'Lookup2D_X_FLOAT32_IEEE'&gt;}\n\n\n\nkey = 'DataLayout.FLOAT32_IEEE'\nkey.split('.')[-1]\n\n'FLOAT32_IEEE'\n\n\n\ncalib = Record.fetch('Calibration.TQD_trqTrqSetNormal_MAP_v')\npprint(calib)\n\ncalib.record_type\ncalib.axes[0].axis_scale.record_type\ncalib.axes[0].axis_scale.record_type.data_type\n\n&lt;Calibration: 'TQD_trqTrqSetNormal_MAP_v'&gt;\n\n\n&lt;DataLayout: 'Lookup2D_FLOAT32_IEEE'&gt;\n\n\n&lt;DataLayout: 'Lookup2D_X_FLOAT32_IEEE'&gt;\n\n\n'FLOAT32_IEEE'\n\n\n\ncalib.axes[0].axis_scale.input\ncalib.axes[0].axis_scale.input.address\ncalib.axes[0].axis_scale.input.record_type\ncalib.axes[0].axis_scale.input.record_type.data_type\ncalib.axes[0].axis_scale.record_type\ncalib.axes[0].axis_scale.data_conversion\ncalib.axes[0].data_conversion.Format\n\n&lt;Measurement: 'TQD_vVehSpd'&gt;\n\n\n'700100f8'\n\n\n&lt;DataLayout: 'Scalar_FLOAT32_IEEE'&gt;\n\n\n'FLOAT32_IEEE'\n\n\n&lt;DataLayout: 'Lookup2D_X_FLOAT32_IEEE'&gt;\n\n\n&lt;DataConversion: 'VBU_L045A_CWP_05_09T_AImode_CM_single'&gt;\n\n\n{'Value': '%8.6'}\n\n\n\ncalib.axes[1].axis_scale.input\ncalib.axes[1].axis_scale.input.address\ncalib.axes[1].axis_scale.input.record_type\ncalib.axes[1].axis_scale.input.record_type.data_type\ncalib.axes[1].axis_scale.record_type\ncalib.axes[1].axis_scale.data_conversion\ncalib.axes[1].data_conversion.Format\n\n&lt;Measurement: 'TQD_pctAccPedPosFlt'&gt;\n\n\n'700100a0'\n\n\n&lt;DataLayout: 'Scalar_FLOAT32_IEEE'&gt;\n\n\n'FLOAT32_IEEE'\n\n\n&lt;DataLayout: 'Lookup2D_X_FLOAT32_IEEE'&gt;\n\n\n&lt;DataConversion: 'VBU_L045A_CWP_05_09T_AImode_CM_single'&gt;\n\n\n{'Value': '%8.6'}\n\n\n\n\n\nload_a2l_lazy\n\n load_a2l_lazy (path:pathlib.Path, leaves:list[str])\n\n*Search for the calibration key in the A2L file. Descripttion: Load the A2L file as a dictionary.\nArgs: path (str): The path to the A2L file. calib_key (str): The node path to the calibration parameters.\nReturns: dict: The A2L file as a dictionary.*\n\n# parser = get_argparser()\nargs = parser.parse_args(\n    [\n        \"-p\",\n        # r\"../res/VBU_AI.json\",\n        r\"../res/VBU_AI.json\",\n        \"-n\",\n        r\"/PROJECT/MODULE[], \",\n        # r\"/PROJECT/MODULE[]/CHARACTERISTIC[], \"\n        #   r\"/PROJECT/MODULE[]/MEASUREMENT[], \"\n        #   r\"/PROJECT/MODULE[]/AXIS_PTS[], \"\n        #   r\"/PROJECT/MODULE[]/COMPU_METHOD[]\",\n        \"-l\",\n        r\"TQD_trqTrqSetNormal_MAP_v, \" \n                r\"VBU_L045A_CWP_05_09T_AImode_CM_single, \" \n                r\"Lookup2D_FLOAT32_IEEE, \"\n                r\"Lookup2D_X_FLOAT32_IEEE, \"\n                r\"TQD_vVehSpd, \"\n                r\"TQD_vSgndSpd_MAP_y, \"\n                r\"TQD_pctAccPedPosFlt, \"\n                r\"TQD_pctAccPdl_MAP_x\",\n    ]\n)\n# args.__dict__\nargs.path, args.leaves, args.node_path\n\n('../res/VBU_AI.json',\n ['TQD_trqTrqSetNormal_MAP_v',\n  'VBU_L045A_CWP_05_09T_AImode_CM_single',\n  'Lookup2D_FLOAT32_IEEE',\n  'Lookup2D_X_FLOAT32_IEEE',\n  'TQD_vVehSpd',\n  'TQD_vSgndSpd_MAP_y',\n  'TQD_pctAccPedPosFlt',\n  'TQD_pctAccPdl_MAP_x'],\n '/PROJECT/MODULE[], ')\n\n\n\n\n\nload_a2l_eager\n\n load_a2l_eager (path:pathlib.Path,\n                 jnode_path:__main__.JsonNodePath=&lt;JsonNodePath [&lt;PROJECT\n                 dict&gt;, &lt;MODULE[] list&gt;]&gt;)\n\n*Load the A2L file as a dictionary. Descripttion: Load the A2L file as a dictionary.\nArgs: path (Path): The path to the A2L file. node (str): The node to search for, e.g.Â â€œ/PROJECT/MODULE[0]/CHARACTERISTICâ€.\nReturns: dict: The A2L file as a dictionary.*\n\nargs.path, args.node_path, args.leaves\n\n('../res/VBU_AI.json',\n '/PROJECT/MODULE[], ',\n ['TQD_trqTrqSetNormal_MAP_v',\n  'VBU_L045A_CWP_05_09T_AImode_CM_single',\n  'Lookup2D_FLOAT32_IEEE',\n  'Lookup2D_X_FLOAT32_IEEE',\n  'TQD_vVehSpd',\n  'TQD_vSgndSpd_MAP_y',\n  'TQD_pctAccPedPosFlt',\n  'TQD_pctAccPdl_MAP_x'])\n\n\n\nrecords = load_records_lazy(args.path, args.leaves, JsonNodePath(args.node_path))\n\n918 ms Â± 0 ns per loop (mean Â± std. dev. of 1 run, 1 loop each)\n\n\n\nrecords = load_a2l_lazy(args.path, args.leaves)\n\n3.45 s Â± 0 ns per loop (mean Â± std. dev. of 1 run, 1 loop each)\n\n\n\n# %%timeit -n 1 -r 1\ncalibs = load_a2l_eager(args.path, JsonNodePath(args.node_path))\n\n\ncalibs[0]['CHARACTERISTIC'][0]\n\n{'Name': {'Value': 'INP_pVacPres_CUR_v'},\n 'LongIdentifier': {},\n 'Type': 'CURVE',\n 'Address': {'Value': '1879065574', 'Base': 16, 'Size': 8},\n 'Deposit': {'Value': 'Lookup1D_FLOAT32_IEEE'},\n 'MaxDiff': {},\n 'Conversion': {'Value': 'VBU_L045A_CWP_05_09T_AImode_CM_single'},\n 'LowerLimit': {'Value': -3.4e+38,\n  'IntegralSign': '-',\n  'IntegralSize': 1,\n  'DecimalSize': 5},\n 'UpperLimit': {'Value': 3.4e+38, 'IntegralSize': 1, 'DecimalSize': 5},\n 'AXIS_DESCR': [{'Attribute': 'COM_AXIS',\n   'InputQuantity': {'Value': 'NO_INPUT_QUANTITY'},\n   'Conversion': {'Value': 'VBU_L045A_CWP_05_09T_AImode_CM_single'},\n   'MaxAxisPoints': {'Value': 6, 'Base': 10, 'Size': 1},\n   'LowerLimit': {'Value': -3.4e+38,\n    'IntegralSign': '-',\n    'IntegralSize': 1,\n    'DecimalSize': 5},\n   'UpperLimit': {'Value': 3.4e+38, 'IntegralSize': 1, 'DecimalSize': 5},\n   'AXIS_PTS_REF': {'AxisPoints': {'Value': 'INP_uVacPres_CUR_x'}}}]}",
    "crumbs": [
      "A2L"
    ]
  },
  {
    "objectID": "vcantest/ccp.socketcan.html",
    "href": "vcantest/ccp.socketcan.html",
    "title": "CCP over SocketCAN",
    "section": "",
    "text": "# #|export\n# from candycan.data_link_socketcan import done, send_msg",
    "crumbs": [
      "vcantest",
      "CCP over SocketCAN"
    ]
  },
  {
    "objectID": "vcantest/ccp.socketcan.html#types-definition",
    "href": "vcantest/ccp.socketcan.html#types-definition",
    "title": "CCP over SocketCAN",
    "section": "Types definition",
    "text": "Types definition\n\n\ncheck_bus_type\n\n check_bus_type (b:str)\n\n*Summary Check if the CAN bus type is valid\nArgs: b (str): Python CAN bus type to be checked\nReturns: str: Python CAN bus type if valid\nRaises: ValueError: if CAN bus type is invalid*\n\n\n\nCANFilter\n\n CANFilter (can_id:typing.Annotated[int,Gt(gt=0)]=630,\n            can_mask:typing.Annotated[int,Gt(gt=0)]=2047)\n\n*Summary CAN filter for Python CAN bus\nAttributes: can_id (int): CAN message ID can_mask (int): CAN message mask*\n\n\n\nScapyCANSpecs\n\n ScapyCANSpecs (bus_type:typing.Annotated[str,AfterValidator(func=&lt;functio\n                ncheck_bus_typeat0x7f1ceb80ede0&gt;)]='VIRTUAL', channel_seri\n                al_number:typing.Annotated[int,Ge(ge=0),Lt(lt=500)]=3,\n                download_can_id:typing.Annotated[int,Gt(gt=0)]=630,\n                upload_can_id:typing.Annotated[int,Gt(gt=0)]=630,\n                can_filters:Optional[list[__main__.CANFilter]]=None, bit_r\n                ate:typing.Annotated[int,Gt(gt=0),Lt(lt=1000000)]=500000, \n                time_out:typing.Annotated[float,Gt(gt=0.0),Lt(lt=10.0)]=1.\n                0, station_address:typing.Annotated[int,Ge(ge=0),Lt(lt=255\n                )]=0,\n                cntr:typing.Annotated[int,Ge(ge=0),Lt(lt=1000000)]=0,\n                receive_own_messages:bool=True, download_upload:bool=True,\n                diff_mode:bool=False, diff_threshold:float=0.001,\n                last_download_data:Optional[candycan.a2l.XCPData]=None)\n\n*Usage docs: https://docs.pydantic.dev/2.7/concepts/models/\nA base class for creating Pydantic models.\nAttributes: class_vars: The names of classvars defined on the model. private_attributes: Metadata about the private attributes of the model. signature: The signature for instantiating the model.\n__pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n__pydantic_core_schema__: The pydantic-core schema used to build the SchemaValidator and SchemaSerializer.\n__pydantic_custom_init__: Whether the model has a custom `__init__` function.\n__pydantic_decorators__: Metadata containing the decorators defined on the model.\n    This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n__pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n    __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n__pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n__pydantic_post_init__: The name of the post-init method for the model, if defined.\n__pydantic_root_model__: Whether the model is a `RootModel`.\n__pydantic_serializer__: The pydantic-core SchemaSerializer used to dump instances of the model.\n__pydantic_validator__: The pydantic-core SchemaValidator used to validate instances of the model.\n\n__pydantic_extra__: An instance attribute with the values of extra fields from validation when\n    `model_config['extra'] == 'allow'`.\n__pydantic_fields_set__: An instance attribute with the names of fields explicitly set.\n__pydantic_private__: Instance attribute with the values of private attributes set on the model instance.*\n\ntry:\n    m = ScapyCANSpecs(can_type='NATIVE', bus_type='VIRTUAL')\nexcept ValidationError as exc:\n    print(exc)\n\npprint(m.model_dump())\n\n\ndef emulate_call(m: ScapyCANSpecs):\n    m.cntr += 1\n\nfor i in range(3):\n    emulate_call(m)\n    print(f\"{i}: counter {m.cntr}\")",
    "crumbs": [
      "vcantest",
      "CCP over SocketCAN"
    ]
  },
  {
    "objectID": "vcantest/ccp.socketcan.html#ccp-code",
    "href": "vcantest/ccp.socketcan.html#ccp-code",
    "title": "CCP over SocketCAN",
    "section": "CCP code",
    "text": "CCP code\n\n\nCCPCommand\n\n CCPCommand (connect:int=1, set_mta:int=2, disconnect:int=7,\n             download:int=3, download6:int=35, upload:int=4,\n             short_upload:int=15, get_seed:int=18, get_ccp_version:int=27)\n\n*Usage docs: https://docs.pydantic.dev/2.7/concepts/models/\nA base class for creating Pydantic models.\nAttributes: class_vars: The names of classvars defined on the model. private_attributes: Metadata about the private attributes of the model. signature: The signature for instantiating the model.\n__pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n__pydantic_core_schema__: The pydantic-core schema used to build the SchemaValidator and SchemaSerializer.\n__pydantic_custom_init__: Whether the model has a custom `__init__` function.\n__pydantic_decorators__: Metadata containing the decorators defined on the model.\n    This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n__pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n    __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n__pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n__pydantic_post_init__: The name of the post-init method for the model, if defined.\n__pydantic_root_model__: Whether the model is a `RootModel`.\n__pydantic_serializer__: The pydantic-core SchemaSerializer used to dump instances of the model.\n__pydantic_validator__: The pydantic-core SchemaValidator used to validate instances of the model.\n\n__pydantic_extra__: An instance attribute with the values of extra fields from validation when\n    `model_config['extra'] == 'allow'`.\n__pydantic_fields_set__: An instance attribute with the names of fields explicitly set.\n__pydantic_private__: Instance attribute with the values of private attributes set on the model instance.*\n\nxcp_calib_from_xcpjson = Get_XCPCalib_From_XCPJSon(args.input)\nxcp_calib_from_xcpjson\n\n\nxcp_data = Generate_Init_XCPData_From_A2L(\n    a2l=args.a2l, keys=args.leaves, node_path=args.node_path\n)\n\n#  address from xcp data file should align with the address from xcp calib file\ntest_eq(xcp_data.address, xcp_calib_from_xcpjson.data[0].address)\n\n# validate the model\ntry:\n    XCPData.model_validate(xcp_data)\nexcept ValidationError as exc:\n    print(exc)\n\n\n# type(args.channel), type(args.download_id), args.upload_id, args.download, args.diff_flashing\n\n\nxcp_data.value = xcp_calib_from_xcpjson.data[0].value\npprint(xcp_data)\nxcp_data.value_array_view[0,2], xcp_data.value_array_view[2,0]\n\n\nxcp_calib = XCPCalib(\n    config=XCPConfig(\n        channel=args.channel_serial_number, download=args.download_can_id, upload=args.upload_can_id\n    ),\n    data=[xcp_data],\n)\n\n\npprint(xcp_calib)\n\n\nnpa =  xcp_calib.data[0].value_array_view\nnpa.shape, npa.dtype, npa\nlen(xcp_calib.data[0].value_bytes), xcp_calib.data[0].value_bytes\n\nlen(npa.tobytes()), npa.tobytes()\ntest_eq(npa.tobytes(), xcp_calib.data[0].value_bytes)\nxcp_calib.data[0].value\n\n\naddr = bytes('7000aa2a', 'utf-8')\na = 0x7000aa2a\na\n\n\nnpb = npa[::-1]\n# npb\nbuffer = [struct.pack(\"&lt;f\", x) for x in np.nditer(npa)]\n# buffer\nlen(buffer)\n\n\n\ninvestigate int type and type size\n\nxcp_data = xcp_calib.data[0]\nadd = int(xcp_data.address, base=16)\nxcp_data.address, add\nhex(add), type(add), sys.getsizeof(add)\nstruct.calcsize('h'), struct.calcsize('i'), struct.calcsize('l'), struct.calcsize('L')\ntype(xcp_data.address),len(xcp_data.address)\n\n\n\n\nnpa_to_packed_buffer\n\n npa_to_packed_buffer (a:numpy.ndarray)\n\n*convert a numpy array to a packed string buffer for flashing TODO: implementation as numpy ufunc\nArgs: a (np.ndarray): input numpy array for flashing\nReturns: str: packed string buffer for flashing*\n\n# buffer = [struct.pack(\"&lt;f\", x).hex() for x in np.nditer(npa)]\n# buffer[::-1]\n# len(buffer)\n# buffer\n# data = ''.join(buffer)\ndata = npa_to_packed_buffer(npa)\ntest_eq(data, xcp_calib.data[0].value)\n# data",
    "crumbs": [
      "vcantest",
      "CCP over SocketCAN"
    ]
  },
  {
    "objectID": "vcantest/ccp.socketcan.html#convert-a-numpy-array-to-a-continuous-hex-string",
    "href": "vcantest/ccp.socketcan.html#convert-a-numpy-array-to-a-continuous-hex-string",
    "title": "CCP over SocketCAN",
    "section": "convert a numpy array to a continuous hex string",
    "text": "convert a numpy array to a continuous hex string\n\n# npa.astype(np.float32).tobytes().hex()\nbuffer = npa.astype(np.float32).tobytes().hex()  ## == npa_to_packed_buffer(npa)\nbuffer, len(buffer)\ntest_eq(buffer, xcp_calib.data[0].value)\n\n\n\nflash_xcp\n\n flash_xcp (xcp_calib:candycan.a2l.XCPCalib,\n            data:pandas.core.frame.DataFrame, diff_flashing:bool=False,\n            download:bool=True)\n\n*Summary Flash XCP data to target\nArgs: xcp_calib (XCPCalib): XCP calibration as template, contains all the meta information except for data xcp_data (pd.DataFrame): input XCP data to be flashed, replace the value in xcp_calib diff_flashing (bool): Use differential flashing download (bool): Download or upload*",
    "crumbs": [
      "vcantest",
      "CCP over SocketCAN"
    ]
  },
  {
    "objectID": "vcantest/ccp.socketcan.html#create-sample-data-for-testing",
    "href": "vcantest/ccp.socketcan.html#create-sample-data-for-testing",
    "title": "CCP over SocketCAN",
    "section": "create sample data for testing",
    "text": "create sample data for testing\n\nxcp_calib.config.download_can_id\nhex(xcp_calib.config.download_can_id)\n\n\nxcp_calib.data\n\n\nxcp_data = xcp_calib.data[0]\nxcp_data.address, xcp_data.type_size, xcp_data.dim, xcp_data.value_array_view, xcp_data.value_bytes\nlen(xcp_data.value_bytes)\nxcp_data.value",
    "crumbs": [
      "vcantest",
      "CCP over SocketCAN"
    ]
  },
  {
    "objectID": "vcantest/ccp.socketcan.html#test-bytes-hex-encodeing-and-decoding",
    "href": "vcantest/ccp.socketcan.html#test-bytes-hex-encodeing-and-decoding",
    "title": "CCP over SocketCAN",
    "section": "Test bytes hex encodeing and decoding",
    "text": "Test bytes hex encodeing and decoding\n\nlen_in_bytes = xcp_data.type_size * xcp_data.dim[0] * xcp_data.dim[1]\nprint(f\"len_in_bytes: {len_in_bytes} = type_size: {xcp_data.type_size} x dim: {xcp_data.dim}\")\n\ndownload_times = len_in_bytes // 6\nlast_download_size = len_in_bytes % 6\nprint(f\"download_times: {download_times}, last_download_size: {last_download_size}\")\n\n\nxcp_data.value_bytes\nlen(xcp_data.value_bytes)\ntile0 = xcp_data.value_bytes[0:6]\nlen(tile0), tile0, tile0.hex(), type(tile0)\ntile1 = xcp_data.value_bytes[6:12]\nlen(tile1), tile1, tile1.hex()\n\n\ntile0 = xcp_data.value_bytes[0:4]\nlen(tile0), tile0, tile0.hex(), type(tile0), struct.unpack(\"&lt;f\", tile0)\n\n\ntile1 = xcp_data.value_bytes[4:8]\nlen(tile1), tile1, tile1.hex(), struct.unpack(\"&lt;f\", tile1)\n\n\ntile2 = xcp_data.value_bytes[8:12]\nlen(tile2), tile2, tile2.hex(), struct.unpack(\"&lt;f\", tile2)\n\n\nst = 2*17*4\ntile3 = xcp_data.value_bytes[st:st+4]\nlen(tile1), tile3, tile3.hex(), struct.unpack(\"&lt;f\", tile3)\nxcp_data.value_array_view[2,0]\ntest_eq(struct.unpack(\"&lt;f\", tile3), xcp_data.value_array_view[2,0])\n\n\ntile3, len(tile3)\ntile3.hex(), len(tile3.hex())\ntile3.hex().encode(), len(tile3.hex().encode()), \ntile3.hex().encode().hex(), len(tile3.hex().encode().hex())\ntry:\n    tile3.hex().hex()\nexcept Exception as exc:\n    print(exc)\ntry:\n    tile3.decode(\"utf-8\"), len(tile3.decode())\nexcept Exception as exc:\n    print(exc)\n\n\ntile3.decode('utf-16')\ntile3.decode('utf-32','backslashreplace')\nt3  = tile3.decode('utf-8','backslashreplace')\nt3, len(t3), type(t3)\nt4  = tile3.decode('utf-8','ignore')\nt4, len(t4), type(t4)\n\n\ntype(tile3)\nlist(tile3)\n\n\nba_uploaded = bytearray()\nba_uploaded += tile3\nba_uploaded\nba_uploaded += tile2\nba_uploaded += tile1\nba_uploaded, len(ba_uploaded)\n\n\nba_uploaded = bytearray()\nlen_in_bytes = xcp_data.type_size * xcp_data.dim[0] * xcp_data.dim[1]\ndownload_times = len_in_bytes // 6\nlast_download_size = len_in_bytes % 6\nfor tile in range(download_times):\n    ba_uploaded += xcp_data.value_bytes[tile*6:(tile+1)*6]\nif last_download_size:\n    ba_uploaded += xcp_data.value_bytes[download_times*6:download_times*6+last_download_size]\n\nlen(ba_uploaded), ba_uploaded.hex()\ntest_eq(ba_uploaded, xcp_data.value_bytes)\ntest_eq(ba_uploaded.hex(), xcp_data.value)\nba_uploaded.hex()",
    "crumbs": [
      "vcantest",
      "CCP over SocketCAN"
    ]
  },
  {
    "objectID": "vcantest/ccp.socketcan.html#cro-for-connection",
    "href": "vcantest/ccp.socketcan.html#cro-for-connection",
    "title": "CCP over SocketCAN",
    "section": "CRO for connection",
    "text": "CRO for connection\n\nCreate can data as bytes of little endianness\n\nb1 = ccp_command.connect.to_bytes(byteorder='little', length=1)\nccp_command.connect, b1, b1.hex()\ncntr = 2\nb2 = cntr.to_bytes(byteorder='little', length=1)\nb2, b2.hex()\ncan_data =  b1 + b2\ncan_data, can_data.hex()\n\n\ncntr, ccp_command.connect, can_specs.station_address\n\ncro_little = struct.pack(\"@BB\", ccp_command.connect, cntr) + can_specs.station_address.to_bytes(byteorder='little', length=2)\ncro_big = can_specs.station_address.to_bytes(byteorder='big', length=2) + struct.pack(\"&gt;BB\", cntr, ccp_command.connect) \ncro_little, cro_big\ncro = cro_big\ncro, cro.hex()\n\nstruct.unpack(\"@BBH\", cro)\n\n\n# cro_little = struct.pack(\"@bb\", ccp_command.connect, cntr) + can_specs.station_address.to_bytes(byteorder='little', length=2)\n# cro_big = can_specs.station_address.to_bytes(byteorder='big', length=2) + struct.pack(\"&gt;bb\", cntr, ccp_command.connect) \ncro_little = struct.pack(\"@bb\", ccp_command.connect, cntr) \ncro_big = struct.pack(\"&gt;bb\", cntr, ccp_command.connect) \ncro = cro_big\ncro, cro.hex()\n# struct.unpack(\"@bbh\", cro)\nstruct.unpack(\"@bb\", cro)\n\n\ntry:\n    d = struct.pack(\"@cc\", cntr, ccp_command.connect)\n    d, d.hex()\nexcept Exception as exc:\n    print(exc)\n\n\ndevice, can_specs.bit_rate, can_specs.can_filters, can_specs.station_address\ncro\n\n\n# send connect message\n# with can.interface.Bus(bustype='socketcan', channel=device, bitrate=can_specs.bit_rate, filter=can_specs.can_filters) as bus:\n# with can.interface.Bus(interface='socketcan', channel=device, bitrate=can_specs.bit_rate) as bus:\nwith can.interface.Bus(interface='socketcan', channel=device, bitrate=can_specs.bit_rate, receive_own_message=True) as bus:\n    msg = can.Message(\n        arbitration_id=can_specs.download_can_id, \n        data=cro, \n        is_extended_id=False)\n    try:\n        bus.send(msg)\n        cntr += 1\n        print(f\"Message sent: {msg} on {bus.channel_info} cntr: {cntr-1}\")\n    except can.CanError:\n        print(\"Message NOT sent\")\n    \n    dto = bus.recv(timeout=can_specs.time_out)\n    dto\n\n\ncan_specs.time_out\n\n\n# with can.interface.Bus(interface='socketcan', channel=device, bitrate=can_specs.bit_rate, filter=can_specs.can_filters):\nwith can.interface.Bus(interface='socketcan', channel=device, bitrate=can_specs.bit_rate) as bus:\n    dto: can.Message = bus.recv(timeout=can_specs.time_out)\n    print(dto)\n\n\n# while(True):\nwith can.interface.Bus(interface='socketcan', channel=device, bitrate=can_specs.bit_rate) as bus:\n    for msg in bus:\n        print(msg)\n# print('Message received: ', dto.arbitration_id, dto.data, dto.timestamp, dto.dlc)\n\n\n# # send connect message\n# with can.interface.Bus(bustype='socketcan', channel=device, bitrate=can_specs.bit_rate, filter=can_specs.can_filters) as bus:\n#     bus.send(msg)\n#     cntr += 1\n#     print(f\"Message sent: {msg}, cntr: {cntr-1}\")\n#     while(True):\n#         bus = can.interface.Bus(bustype='socketcan', channel=device, bitrate=can_specs.bit_rate, filter=can_specs.can_filters)\n#         dto: can.Message = bus.recv()\n#         print(dto)\n#         # print('Message received: ', dto.arbitration_id, dto.data, dto.timestamp, dto.dlc)\n#         if dto.dlc != 3 or dto.arbitration_id != can_specs.upload_can_id:\n#             continue\n#         pid, err_code , cntr_ret = struct.unpack('@BBB', dto.data)\n#         if pid != 0xff:\n#             continue\n#         if cntr_ret == cntr and err_code == 0:\n#             print(f\"Connected: {pid}, {err_code}, {cntr}\")\n#             break\n#         else:\n#             print(f\"Error: {pid}, {err_code}, {cntr}\")\n#             break\n\n\n\nsend SET_MTA message\n\nxcp_data.address\naddr = int(xcp_data.address, 16)\naddr, hex(addr)\na_bytes_little = struct.pack(\"@I\", addr)\na_bytes_big = struct.pack(\"&gt;I\", addr)\na_bytes_little, a_bytes_big\n\n\n# create CAN message for ccp SET_MTA CRO\nxcp_data.address, cntr, ccp_command.set_mta, hex(addr), struct.pack(\"@I\", addr)\ncan_data_big = struct.pack(\"&gt;IBBBB\", int(xcp_data.address,16), 0x00, 0x00, cntr, ccp_command.set_mta)\ncan_data_little = struct.pack(\"@BBBBI\", ccp_command.set_mta, cntr, 0x00, 0x00, int(xcp_data.address,16))\ncan_data_little, can_data_big\ncan_data = can_data_little\ncro = can.Message(arbitration_id=args.download_can_id, \n                            data=can_data, \n                            is_extended_id=False)   \ncro\n\n\n# # set MTA\n# with can.interface.Bus(bustype='socketcan', channel=device, bitrate=args.bit_rate, filter=can_specs.can_filters) as bus:\n#     bus.send(cro)\n#     cntr += 1\n#     print(f\"Message sent: {cro}, cntr: {cntr-1}\")\n    \n#     while(True):\n#         dto: can.Message = bus.recv()\n#         print('Message received: ', dto.arbitration_id, dto.data, dto.timestamp, dto.dlc)\n        \n#         if dto.dlc != 3 or dto.arbitration_id != can_specs.upload_can_id:\n#             continue\n#         pid, err_code , cntr_ret = struct.unpack('@BBB', dto.data)\n#         if pid != 0xff:\n#             continue\n#         if cntr_ret == cntr and err_code == 0:\n#             print(f\"Connected: {pid}, {err_code}, {cntr}\")\n#             break\n#         else:\n#             print(f\"Error: {pid}, {err_code}, {cntr}\")\n#             break",
    "crumbs": [
      "vcantest",
      "CCP over SocketCAN"
    ]
  },
  {
    "objectID": "vcantest/ccp.socketcan.html#download-from-target",
    "href": "vcantest/ccp.socketcan.html#download-from-target",
    "title": "CCP over SocketCAN",
    "section": "Download from target",
    "text": "Download from target\n\n# can_data_big = struct.pack(\"&gt;BBBBBBBB\", int(xcp_data.address,16), 0x00, 0x00, cntr, ccp_command.download6)\ncan_data_little = struct.pack(\"@BB\", ccp_command.download6, cntr)\nccp_command.download6, cntr, can_data_little\n\n\nxcp_data.value_bytes[0:6]\nb = xcp_data.value_bytes[0]\nb, b.to_bytes(), can_data_little + b.to_bytes()\ncan_data_little + xcp_data.value_bytes[0:6]\n\n\ntile = 0\nfor i in range(6):\n    b = xcp_data.value_bytes[tile+i]\n    can_data_little += b.to_bytes()\n    b, can_data_little\n# xcp_data.value_bytes[i*6:(i+1)*6]\ncan_data_little\n\n\nloop over XCPCalib data array\n\nccp_command\n\n\n# for i in range(download_times):\n#     # Create CAN message for ccp DOWNLOAD CRO\n#     # xcp_data.address, cntr, ccp_command.set_mta, hex(addr), struct.pack(\"@I\", addr)\n#     # can_data_big = xcp_data.value_bytes[i*6:(i+1)*6:-1] + can_data_big\n#     can_data_little = struct.pack(\"@BB\", ccp_command.download6, cntr)\n#     can_data_little += xcp_data.value_bytes[i*6:(i+1)*6]\n#     # can_data_little, can_data_big\n#     can_data = can_data_little\n#     cro = can.Message(arbitration_id=args.download_can_id, data=can_data, is_extended_id=False)   \n    \n#     # Download data \n#     with can.interface.Bus(bustype='socketcan', channel=device, bitrate=args.bit_rate, filter=can_specs.can_filters) as bus:\n#         bus.send(cro)\n#         cntr += 1\n#         print(f\"Message sent: {cro}, cntr: {cntr-1}\")\n\n#         while(True):\n#             dto: can.Message = bus.recv()\n#             print('Message received: ', dto.arbitration_id, dto.data, dto.timestamp, dto.dlc)\n\n#             # if dto.arbitration_id != can_specs.upload_can_id:\n#             #     continue\n#             pid, err_code , cntr_ret, mta0_ext, mta0_addr = struct.unpack('@BBBBI', dto.data)\n#             if pid != 0xff:\n#                 continue\n#             if cntr_ret == cntr and err_code == 0:\n#                 print(f\"Downloaded: mta0_ext({mta0_ext}), mta0_add({mta0_addr}), {cntr}\")\n#                 break\n#             else:\n#                 print(f\"Error: {pid}, {err_code}, {cntr}\")\n#                 break\n#     # cro = CCP(identifier=xcp_calib.config.download_can_id)/CRO(ctr=ctr)/DNLOAD_6(data=d.value_bytes[i*6:(i+1)*6])\n#     if i%100==0:\n#         print(f\"i: {i}, cntr: {cntr} cro: {cro}\")\n\n\n\nDownload the last tile\n\n# i = download_times * 6\n# # can_data_big = xcp_data.value_bytes[i*6:(i+1)*6:-1] + can_data_big\n# can_data_little = struct.pack(\"@BB\", ccp_command.download, cntr)\n# can_data_little += xcp_data.value_bytes[i:i+last_download_size]\n# # can_data_little, can_data_big\n# can_data = can_data_little\n# cro = can.Message(arbitration_id=args.download_can_id, data=can_data, is_extended_id=False)   \n    \n# # Download data \n# with can.interface.Bus(bustype='socketcan', channel=device, bitrate=args.bit_rate, filter=can_specs.can_filters) as bus:\n#     bus.send(cro)\n#     cntr += 1\n#     print(f\"Message sent: {cro}, cntr: {cntr-1}\")\n\n#     while(True):\n#         dto: can.Message = bus.recv()\n#         print('Message received: ', dto.arbitration_id, dto.data, dto.timestamp, dto.dlc)\n\n#         # if dto.arbitration_id != can_specs.upload_can_id:\n#         #     continue\n#         pid, err_code , cntr_ret, mta0_ext, mta0_addr = struct.unpack('@BBBBI', dto.data)\n#         if pid != 0xff:\n#             continue\n#         if cntr_ret == cntr and err_code == 0:\n#             print(f\"Downloaded: mta0_ext({mta0_ext}), mta0_add({mta0_addr}), {cntr}\")\n#             break\n#         else:\n#             print(f\"Error: {pid}, {err_code}, {cntr}\")\n#             break",
    "crumbs": [
      "vcantest",
      "CCP over SocketCAN"
    ]
  },
  {
    "objectID": "vcantest/ccp.socketcan.html#disconnect-target-ecu",
    "href": "vcantest/ccp.socketcan.html#disconnect-target-ecu",
    "title": "CCP over SocketCAN",
    "section": "Disconnect target ecu",
    "text": "Disconnect target ecu\n\n# cro = struct.pack(\"@bbb\", ccp_command.disconnect, cntr, 0x01) + b'\\x00' + can_specs.station_address.to_bytes(byteorder='little', length=2) \n# cro, cro.hex()\n# struct.unpack(\"@bbbbh\", cro)\n\n\n# # send disconnect message\n# with can.interface.Bus(bustype='socketcan', channel=device, bitrate=can_specs.bit_rate, filter=can_specs.can_filters) as bus:\n#     bus.send(cro)\n#     cntr += 1\n#     print(f\"Message sent: {cro}, cntr: {cntr-1}\")\n    \n#     while(True):\n#         dto: can.Message = bus.recv()\n#         print('Message received: ', dto.arbitration_id, dto.data, dto.timestamp, dto.dlc)\n        \n#         if dto.dlc != 3 or dto.arbitration_id != can_specs.upload_can_id:\n#             continue\n#         pid, err_code , cntr_ret = struct.unpack('@bbb', dto.data)\n#         if pid != 0xff:\n#             continue\n#         if cntr_ret == cntr and err_code == 0:\n#             print(f\"Connected: {pid}, {err_code}, {cntr}\")\n#             break\n#         else:\n#             print(f\"Error: {pid}, {err_code}, {cntr}\")\n#             break",
    "crumbs": [
      "vcantest",
      "CCP over SocketCAN"
    ]
  },
  {
    "objectID": "vcantest/ccp.socketcan.html#three-context-managers-for-ccp",
    "href": "vcantest/ccp.socketcan.html#three-context-managers-for-ccp",
    "title": "CCP over SocketCAN",
    "section": "Three context managers for CCP",
    "text": "Three context managers for CCP\n\n\ncan_context\n\n can_context (can_specs:__main__.ScapyCANSpecs)\n\n*Summary Context manager for scapy CAN socket\nArgs: can_specs (ScapyCANSpecs): CAN specs including can type, bus type, channel, etc.\nYields: Bus: Python-CAN Bus object*\n\n\n\nSET_MTA_context\n\n SET_MTA_context (can_specs:__main__.ScapyCANSpecs, bus:&lt;function Bus&gt;,\n                  data:candycan.a2l.XCPData)\n\n*Summary Context manager for scapy set_mta\nArgs: channel (str): CAN channel to use, default is vcan0\nYields: CAN: packdet for CAN message*\n\n\n\nXLOAD_context\n\n XLOAD_context (can_specs:__main__.ScapyCANSpecs, bus:&lt;function Bus&gt;,\n                data:candycan.a2l.XCPData, start_index:int, tile_size:int)\n\n*Summary Context manager for scapy load (download or upload)\nArgs: channel (str): CAN channel to use, default is vcan0\nYields: CANSocket: CAN socket object*",
    "crumbs": [
      "vcantest",
      "CCP over SocketCAN"
    ]
  },
  {
    "objectID": "vcantest/ccp.socketcan.html#downloading-and-uploading-with-context-managers",
    "href": "vcantest/ccp.socketcan.html#downloading-and-uploading-with-context-managers",
    "title": "CCP over SocketCAN",
    "section": "Downloading and uploading with context managers",
    "text": "Downloading and uploading with context managers\n\n\nupload_calib_data2\n\n upload_calib_data2 (xcp_calib:candycan.a2l.XCPCalib,\n                     can_specs:__main__.ScapyCANSpecs)\n\n*Summary Upload XCP calibration data from target to host, the result will update the xcp_calib.data field\nArgs: xcp_calib (XCPCalib): XCP calibration to be uploaded from the target to host diff_flashing (bool): Use differential flashing*\n\n\n\ndownlod_calib_data2\n\n downlod_calib_data2 (xcp_calib:candycan.a2l.XCPCalib,\n                      can_specs:__main__.ScapyCANSpecs)\n\n*Summary Download XCP calibration data to target use scapy_can_context\nArgs: xcp_calib (XCPCalib): XCP calibration to be downloaded into the target*\n\ncan_filters = [{'can_id': xcp_calib.config.upload_can_id, 'can_mask': 0x7FF}]\ncan_specs = ScapyCANSpecs(can_type='NATIVE', \n                        bus_type='SOCKET', \n                        channel_serial_number=3,\n                        download_can_id=xcp_calib.config.download_can_id,\n                        upload_can_id=xcp_calib.config.upload_can_id,\n                        can_filters=can_filters,\n                        bit_rate=500_000,\n                        time_out=1.0,\n                        station_address=0x00,\n                        cntr=0,\n                        receive_own_messages=True,\n                        download_upload=True\n                        )\ncan_specs\ncan_specs.model_dump()\n\n\nxcp_calib.config.channel = 0\nxcp_calib\n\n\n# TODO cannot run test on CCP without a real or emulated ECU \n# downlod_calib_data2(xcp_calib, can_type='NATIVE', bus_type='VIRTUAL', bit_rate=500_000, timeout=1.0, station_address=0x00, diff_flashing=False)",
    "crumbs": [
      "vcantest",
      "CCP over SocketCAN"
    ]
  },
  {
    "objectID": "vcantest/ccp.socketcan.html#test-downloading-and-uploading",
    "href": "vcantest/ccp.socketcan.html#test-downloading-and-uploading",
    "title": "CCP over SocketCAN",
    "section": "Test downloading and uploading",
    "text": "Test downloading and uploading\n\nxcp_calib_from_xcpjson = Get_XCPCalib_From_XCPJSon(args.input)\n\nargs.download_can_id = xcp_calib_from_xcpjson.config.download_can_id\nargs.upload_can_id = xcp_calib_from_xcpjson.config.upload_can_id\nargs.channel_serial_number = xcp_calib_from_xcpjson.config.channel\n\nxcp_data = Generate_Init_XCPData_From_A2L(\n    a2l=args.a2l, keys=args.leaves, node_path=args.node_path\n)  # initial xcp_data has value 0\ntry:\n    XCPData.model_validate(xcp_data)\nexcept ValidationError as exc:\n    print(exc)\n\n# emulate torque table input as numpy array\nxcp_data_value_npa = xcp_calib_from_xcpjson.data[0].value_array_view\nxcp_data.value = xcp_data_value_npa.astype(np.float32).tobytes().hex()\npprint(xcp_data)\n\nxcp_calib = XCPCalib(\n    config=XCPConfig(\n        channel=args.channel_serial_number, download=args.download_can_id, upload=args.upload_can_id\n    ),\n    data=[xcp_data],\n)\npprint(xcp_calib)\n\ncan_filters = [{'can_id': xcp_calib.config.upload_can_id, 'can_mask': 0x7FF}]\ncntr = 0\ncan_specs = ScapyCANSpecs(bus_type=args.bus_type,\n                        channel_serial_number=args.channel_serial_number,\n                        download_can_id=xcp_calib.config.download_can_id,\n                        upload_can_id=xcp_calib.config.upload_can_id,\n                        can_filters=can_filters,\n                        bit_rate=args.bit_rate,\n                        time_out=args.time_out,\n                        station_address=args.station_address,\n                        cntr=cntr,\n                        receive_own_messages=True,\n                        download_upload=args.download,  # CCP Upload mode\n                        diff_mode = args.diff_mode,\n                        diff_threshold= args.diff_threshold\n                        )\n\n\ncan_specs\n\n\n# test uploading\n# can_specs.download_upload = False                        \n# upload_calib_data2(xcp_calib=xcp_calib, can_specs=can_specs)",
    "crumbs": [
      "vcantest",
      "CCP over SocketCAN"
    ]
  },
  {
    "objectID": "vcantest/send_message.html",
    "href": "vcantest/send_message.html",
    "title": "send_message",
    "section": "",
    "text": "from pprint import pprint\nimport subprocess\n\n\n\nget_argparser\n\n get_argparser ()\n\n*summary get CAN bus, dbc config and the message to send\nReturns: argparse.ArgumentParser: description*\n\n\n\nsignal_usr1\n\n signal_usr1 (signum, frame)\n\nHandle USR1 signal as an event to set the received flag.\n\n\n\nsend_msg\n\n send_msg (db:cantools.database.can.database.Database, message:str,\n           payload:bytes, channel:str, bitrate:int, bus_type:str,\n           is_extended:bool)\n\n\ndb_can = cantools.database.load_file('../../res/motohawk_new.dbc')\ndb_can.messages\nexample_message: MessageTpl = db_can.get_message_by_name('ExampleMessage')\npprint(example_message.signals)\npprint(example_message.__dict__)\nexample_message.frame_id\n\n\n# install vcan interface with encrypted password to sudo \nos.system(\"gpg -d -q ~/.sshpasswd.gpg | sshpass -v sudo modprobe vcan\")\n# sshpass -v -p asdf sudo ip link add dev vcan0 type vcan\nos.system(\"gpg -d -q ~/.sshpasswd.gpg | sshpass -v sudo ip link add dev vcan0 type vcan\")\nos.system(\"ip link show vcan0\")\n# !gpg -d -q ~/.sshpasswd.gpg | sshpass -v sudo ip link set vcan0 type vcan bitrate 500000  # vcan does not support set bitrate on command line!\n# !sshpass -p asdf sudo ip link add dev vcan0 type vcan\nos.system(\"gpg -d -q ~/.sshpasswd.gpg | sshpass -v sudo ip link set up vcan0\")\n# !sshpass -v -p asdf sudo ip link set up vcan0\n\n\n# # install vcan interface with encrypted password to sudo \n# !gpg -d -q ~/.sshpasswd.gpg | sshpass -v sudo modprobe vcan\n# # sshpass -v -p asdf sudo ip link add dev vcan0 type vcan\n# !gpg -d -q ~/.sshpasswd.gpg | sshpass -v sudo ip link add dev vcan0 type vcan\n# !ip link show vcan0\n# # !gpg -d -q ~/.sshpasswd.gpg | sshpass -v sudo ip link set vcan0 type vcan bitrate 500000  # vcan does not support set bitrate on command line!\n# # !sshpass -p asdf sudo ip link add dev vcan0 type vcan\n# !gpg -d -q ~/.sshpasswd.gpg | sshpass -v sudo ip link set up vcan0\n# # !sshpass -v -p asdf sudo ip link set up vcan0\n\n\ndata_dict ={'Temperature': 250.1, 'AverageRadius': 3.2, 'Enable': 1}\ndata_json_bytes = json.dumps(data_dict).encode('utf-8')\ndata_json_bytes\njson.loads(data_json_bytes.decode())\n\ncan_data = example_message.encode({'Temperature': 250.1, 'AverageRadius': 3.2, 'Enable': 1})\nexample_message.decode(can_data)\n\n\nbus = can.interface.Bus(bustype='socketcan', channel='vcan0', bitrate=250000)\nmessage_to_send = can.Message(arbitration_id=example_message.frame_id, data=can_data, is_extended_id=False)     \n# can_bus.send(message)\n\n\nmanager = Manager()\nmessage_proxy = manager.dict()\n\n\ndef receive_message(message_proxy: DictProxy,bus: can.interface.Bus)-&gt;None:\n    print('waiting for message')\n    msg:can.Message = bus.recv()\n    print('message received')\n    message_proxy['timestamp'] = msg.timestamp\n    message_proxy['arbitration_id'] = msg.arbitration_id\n    message_proxy['data']=msg.data\n\n\nproc = subprocess.Popen(\n    ['python', \n        '../../candycan/send_message.py', \n        '-t', 'socketcan', \n        '-c' , 'vcan0', \n        '-b', '25000',\n        '-d', '../../res/motohawk_new.dbc',\n        '-m', 'ExampleMessage',\n        ], \n    stdout=subprocess.PIPE, \n    stderr=subprocess.PIPE, \n    stdin=subprocess.PIPE\n    )\nprint(f'PARENT: {proc.pid} before signaling child')\n\n\ndata_json_bytes\ndata_json_bytes.decode()\njson.loads(data_json_bytes.decode())\n\n\ntry:\n    outs, errs = proc.communicate(data_json_bytes, timeout=1)\nexcept subprocess.TimeoutExpired:\n    print(f'PARENT: {proc.pid}; TimeoutExpired')\n    # outs, errs = proc.communicate()\n    # print(f'PARENT: {proc.pid}; outs: {outs}; errs: {errs} TimeoutExpired')\n# sys.stdout.flush()\n# time.sleep(1)\n\n\nreceive_message(message_proxy, bus)\n# proc_receive = subprocess.Popen(\n#   ['python', \n#         '../candycan/receive_message.py', \n#       '-t', 'socketcan', \n#       '-c' , 'vcan0', \n#       '-b', '25000',\n#       '-d', '../res/motohawk_new.dbc',\n#       '-m', 'ExampleMessage',\n#       ], \n#   # stdout=subprocess.PIPE, \n#   # stderr=subprocess.PIPE, \n#   # stdin=subprocess.PIPE\n#   )\n# print(f'PARENT: {proc.pid} before signaling child')\n\n# stdout_raw, stderr_raw = proc_receive.communicate()\n# stdout_value = stdout_raw.decode('utf-8')\n# stderr_value = stderr_raw.decode('utf-8')\n# # [0].decode('utf-8')\n# stdout_value\n# stderr_value\n\n\nprint(f'PARENT: {proc.pid} signaling child')\n# sys.stdout.flush()\nos.kill(proc.pid, signal.SIGUSR1)\n\n\nstdout_raw, stderr_raw = proc.communicate()\nstdout_value = stdout_raw.decode('utf-8')\nstderr_value = stderr_raw.decode('utf-8')\n\nprint(f'stdout: {repr(stdout_value)}; stderr: {repr(stderr_value)}')\n# [0].decode('utf-8')\n\n\ndatetime.fromtimestamp(message_proxy['timestamp']),db_can.decode_message(message_proxy['arbitration_id'],message_proxy['data'])\n\n\n# close and remove vcan0\n# !sshpass -v -p  asdf sudo ip link delete vcan0 \n\nos.system(\"gpg -d -q ~/.sshpasswd.gpg | sshpass -v sudo ip link set down vcan0\")\n\n\n# delete vcan0\nos.system(\"gpg -d -q ~/.sshpasswd.gpg | sshpass -v sudo ip link delete vcan0\")",
    "crumbs": [
      "vcantest",
      "send_message"
    ]
  },
  {
    "objectID": "04.data_link.socketcan.html",
    "href": "04.data_link.socketcan.html",
    "title": "data link layer with socket can",
    "section": "",
    "text": "get_argparser\n\n get_argparser ()\n\n*summary get CAN bus, dbc config and the message to send\nReturns: argparse.ArgumentParser: description*\n\n\n\nsignal_usr1\n\n signal_usr1 (signum, frame)\n\nHandle USR1 signal as an event to set the received flag.\n\n\n\nsend_msg\n\n send_msg (db:cantools.database.can.database.Database, message:str,\n           payload:bytes, channel:str, bitrate:int, bus_type:str,\n           is_extended:bool)\n\nsend a CAN frame with bytes interface, the multiprocessing interface has to use PIPE which is character based.\n\ndb_can = cantools.database.load_file(repo.working_dir+'/res/motohawk_new.dbc')\ndb_can.messages\n\n[message('ExampleMessage', 0x1f0, False, 8, {None: 'Example message used as template in MotoHawk models.'}),\n message('NewMessage', 0x254, False, 8, {None: 'self made message'})]\n\n\n\nexample_message: MessageTpl = db_can.get_message_by_name('ExampleMessage')\npprint(example_message.signals)\npprint(example_message.__dict__)\nexample_message.frame_id\n\n[signal('Enable', 7, 1, 'big_endian', False, None, 1, 0, None, None, '-', False, None, {0: 'Disabled', 1: 'Enabled'}, None, None),\n signal('AverageRadius', 6, 6, 'big_endian', False, None, 0.1, 0, 0, 5, 'm', False, None, None, None, None),\n signal('Temperature', 0, 12, 'big_endian', True, None, 0.01, 250, 229.52, 270.47, 'degK', False, None, None, None, None)]\n{'_autosar': None,\n '_bus_name': None,\n '_codecs': {'formats': Formats(big_endian=&lt;bitstruct.c.CompiledFormatDict object&gt;, little_endian=&lt;bitstruct.c.CompiledFormatDict object&gt;, padding_mask=35184372088831),\n             'multiplexers': {},\n             'signals': [signal('Enable', 7, 1, 'big_endian', False, None, 1, 0, None, None, '-', False, None, {0: 'Disabled', 1: 'Enabled'}, None, None),\n                         signal('AverageRadius', 6, 6, 'big_endian', False, None, 0.1, 0, 0, 5, 'm', False, None, None, None, None),\n                         signal('Temperature', 0, 12, 'big_endian', True, None, 0.01, 250, 229.52, 270.47, 'degK', False, None, None, None, None)]},\n '_comments': {None: 'Example message used as template in MotoHawk models.'},\n '_contained_messages': None,\n '_cycle_time': None,\n '_dbc': &lt;cantools.database.can.formats.dbc_specifics.DbcSpecifics object&gt;,\n '_frame_id': 496,\n '_header_byte_order': 'big_endian',\n '_header_id': None,\n '_is_extended_frame': False,\n '_is_fd': False,\n '_length': 8,\n '_name': 'ExampleMessage',\n '_protocol': None,\n '_send_type': None,\n '_senders': ['PCM1'],\n '_signal_dict': {'AverageRadius': signal('AverageRadius', 6, 6, 'big_endian', False, None, 0.1, 0, 0, 5, 'm', False, None, None, None, None),\n                  'Enable': signal('Enable', 7, 1, 'big_endian', False, None, 1, 0, None, None, '-', False, None, {0: 'Disabled', 1: 'Enabled'}, None, None),\n                  'Temperature': signal('Temperature', 0, 12, 'big_endian', True, None, 0.01, 250, 229.52, 270.47, 'degK', False, None, None, None, None)},\n '_signal_groups': [],\n '_signal_tree': ['Enable', 'AverageRadius', 'Temperature'],\n '_signals': [signal('Enable', 7, 1, 'big_endian', False, None, 1, 0, None, None, '-', False, None, {0: 'Disabled', 1: 'Enabled'}, None, None),\n              signal('AverageRadius', 6, 6, 'big_endian', False, None, 0.1, 0, 0, 5, 'm', False, None, None, None, None),\n              signal('Temperature', 0, 12, 'big_endian', True, None, 0.01, 250, 229.52, 270.47, 'degK', False, None, None, None, None)],\n '_strict': True,\n '_unused_bit_pattern': 255}\n\n\n496\n\n\n\nif blue_pill:\n    # install vcan interface with encrypted password to sudo \n    os.system(\"gpg -d -q ~/.sshpasswd.gpg | sshpass -v sudo modprobe vcan\")\n    # sshpass -v -p asdf sudo ip link add dev vcan0 type vcan\n    os.system(\"gpg -d -q ~/.sshpasswd.gpg | sshpass -v sudo ip link add dev vcan0 type vcan\")\n    os.system(\"ip link show vcan0\")\n    # !gpg -d -q ~/.sshpasswd.gpg | sshpass -v sudo ip link set vcan0 type vcan bitrate 500000  # vcan does not support set bitrate on command line!\n    # !sshpass -p asdf sudo ip link add dev vcan0 type vcan\n    os.system(\"gpg -d -q ~/.sshpasswd.gpg | sshpass -v sudo ip link set up vcan0\")\n    # !sshpass -v -p asdf sudo ip link set up vcan0\nelse:\n    os.system(\"sudo modprobe vcan\")\n    os.system(\"sudo ip link add dev vcan0 type vcan\")\n    os.system(\"ip link show vcan0\")\n    os.system(\"sudo ip link set up vcan0\")\n\nSSHPASS: searching for password prompt using match \"assword\"\nSSHPASS: read: [sudo] password for n: \nSSHPASS: detected prompt. Sending password.\nSSHPASS: read: \n\nSSHPASS: searching for password prompt using match \"assword\"\nSSHPASS: read: [sudo] password for n: \nSSHPASS: detected prompt. Sending password.\nSSHPASS: read: \n\nSSHPASS: searching for password prompt using match \"assword\"\nSSHPASS: read: [sudo] password for n: \nSSHPASS: detected prompt. Sending password.\nSSHPASS: read: \n\n\n\n0\n\n\n0\n\n\n59: vcan0: &lt;NOARP&gt; mtu 72 qdisc noop state DOWN mode DEFAULT group default qlen 1000\n    link/can \n\n\n0\n\n\n0\n\n\n\ndata_dict ={'Temperature': 250.1, 'AverageRadius': 3.2, 'Enable': 1}\ndata_json_bytes = json.dumps(data_dict).encode('utf-8')\ndata_json_bytes, len(data_json_bytes)\njson.loads(data_json_bytes.decode())\n\ncan_data = example_message.encode({'Temperature': 250.1, 'AverageRadius': 3.2, 'Enable': 1})\ncan_data\nexample_message.decode(can_data)\n\n(b'{\"Temperature\": 250.1, \"AverageRadius\": 3.2, \"Enable\": 1}', 57)\n\n\n{'Temperature': 250.1, 'AverageRadius': 3.2, 'Enable': 1}\n\n\nb'\\xc0\\x01@\\x00\\x00\\x00\\x00\\x00'\n\n\n{'Enable': 'Enabled', 'AverageRadius': 3.2, 'Temperature': 250.1}\n\n\n\nbus = can.interface.Bus(bustype='socketcan', channel='vcan0', bitrate=250000)\nmessage_to_send = can.Message(arbitration_id=example_message.frame_id, data=can_data, is_extended_id=False)     \n# can_bus.send(message)\n\n\nmanager = Manager()\nmessage_proxy = manager.dict()\n\n\n\n\nreceive_message\n\n receive_message (message_proxy:multiprocessing.managers.DictProxy,\n                  bus:&lt;function Bus&gt;)\n\n\nproc = subprocess.Popen(\n    ['python', \n        repo.working_dir+'/candycan/data_link/socketcan.py', \n        '-t', 'socketcan', \n        '-c' , 'vcan0', \n        '-b', '25000',\n        '-d', repo.working_dir+'/res/motohawk_new.dbc',\n        '-m', 'ExampleMessage',\n        ], \n    stdout=subprocess.PIPE, \n    stderr=subprocess.PIPE, \n    stdin=subprocess.PIPE\n    )\nprint(f'PARENT: {proc.pid} before signaling child')\n\nPARENT: 2374549 before signaling child\n\n\n\ndata_json_bytes\ndata_json_bytes.decode()\njson.loads(data_json_bytes.decode())\n\nb'{\"Temperature\": 250.1, \"AverageRadius\": 3.2, \"Enable\": 1}'\n\n\n'{\"Temperature\": 250.1, \"AverageRadius\": 3.2, \"Enable\": 1}'\n\n\n{'Temperature': 250.1, 'AverageRadius': 3.2, 'Enable': 1}\n\n\n\ntry:\n    outs, errs = proc.communicate(data_json_bytes, timeout=1)\nexcept subprocess.TimeoutExpired:\n    print(f'PARENT: {proc.pid}; TimeoutExpired')\n    # outs, errs = proc.communicate()\n    # print(f'PARENT: {proc.pid}; outs: {outs}; errs: {errs} TimeoutExpired')\n# sys.stdout.flush()\n# time.sleep(1)\n\nPARENT: 2374549; TimeoutExpired\n\n\n\nreceive_message(message_proxy, bus)\n# proc_receive = subprocess.Popen(\n#   ['python', \n#         '../candycan/receive_message.py', \n#       '-t', 'socketcan', \n#       '-c' , 'vcan0', \n#       '-b', '25000',\n#       '-d', '../res/motohawk_new.dbc',\n#       '-m', 'ExampleMessage',\n#       ], \n#   # stdout=subprocess.PIPE, \n#   # stderr=subprocess.PIPE, \n#   # stdin=subprocess.PIPE\n#   )\n# print(f'PARENT: {proc.pid} before signaling child')\n\n# stdout_raw, stderr_raw = proc_receive.communicate()\n# stdout_value = stdout_raw.decode('utf-8')\n# stderr_value = stderr_raw.decode('utf-8')\n# # [0].decode('utf-8')\n# stdout_value\n# stderr_value\n\nwaiting for message\nmessage received\n\n\n\nprint(f'PARENT: {proc.pid} signaling child')\n# sys.stdout.flush()\nos.kill(proc.pid, signal.SIGUSR1)\n\nPARENT: 2374549 signaling child\n\n\n\nstdout_raw, stderr_raw = proc.communicate()\nstdout_value = stdout_raw.decode('utf-8')\nstderr_value = stderr_raw.decode('utf-8')\n\nprint(f'stdout: {repr(stdout_value)}; stderr: {repr(stderr_value)}')\n# [0].decode('utf-8')\n\nstdout: \"'/home/n/devel/candycan'\\nSignal received after 0.748 seconds\\n\"; stderr: ''\n\n\n\ndatetime.fromtimestamp(message_proxy['timestamp']),db_can.decode_message(message_proxy['arbitration_id'],message_proxy['data'])\n\n(datetime.datetime(2024, 4, 10, 18, 22, 21, 283114),\n {'Enable': 'Enabled', 'AverageRadius': 3.2, 'Temperature': 250.1})\n\n\n\nif blue_pill:\n    # close and remove vcan0\n    os.system(\"gpg -d -q ~/.sshpasswd.gpg | sshpass -v sudo ip link set down vcan0\")\n    # delete vcan0\n    os.system(\"gpg -d -q ~/.sshpasswd.gpg | sshpass -v sudo ip link delete vcan0\")\nelse:\n    # close and remove vcan0\n    os.system(\"sudo ip link set down vcan0\")\n    # delete vcan0\n    os.system(\"sudo ip link delete vcan0\")\n\nSSHPASS: searching for password prompt using match \"assword\"\nSSHPASS: read: [sudo] password for n: \nSSHPASS: detected prompt. Sending password.\nSSHPASS: read: \n\nSSHPASS: searching for password prompt using match \"assword\"\nSSHPASS: read: [sudo] password for n: \nSSHPASS: detected prompt. Sending password.\nSSHPASS: read: \n\n\n\n0\n\n\n0",
    "crumbs": [
      "data link layer with socket can"
    ]
  }
]