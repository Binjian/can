# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02.ccp.ipynb.

# %% auto 0
__all__ = ['pp', 'repo', 'CAN_TYPES', 'CANType', 'CAN_BUS_TYPES', 'CANBusType', 'get_argparser', 'npa_to_packed_buffer',
           'flash_xcp', 'check_can_type', 'check_can_bus_type', 'downlod_calib_data', 'upload_calib_data',
           'scapy_cpp_can_connect']

# %% ../nbs/02.ccp.ipynb 3
import os
import git
import argparse
from InquirerPy import inquirer
from InquirerPy.validator import EmptyInputValidator
from InquirerPy.base.control import Choice
from pydantic import BaseModel, Field,  ConfigDict, model_validator, conlist, ValidationError
from pydantic.functional_validators import AfterValidator
from typing import Optional
from typing_extensions import Annotated
from pprint import pprint, PrettyPrinter

# %% ../nbs/02.ccp.ipynb 4
import subprocess
from multiprocessing import Manager
from multiprocessing.managers import DictProxy
import cantools
from cantools.database import Message as MessagerTpl
from cantools.database.can.database import Database
import contextlib

# %% ../nbs/02.ccp.ipynb 5
import pandas as pd
import numpy as np
import struct

# %% ../nbs/02.ccp.ipynb 7
from candycan.a2l import (
    list_of_strings,
    XCPCalib,
    XCPData,
    XCPConfig,
    Get_XCPCalib_From_XCPJSon,
    Generate_Init_XCPData_From_A2L,
)


# %% ../nbs/02.ccp.ipynb 8
from scapy.all import (
    raw, rdpcap, wrpcap, load_contrib, hexdump,
    ls, conf, load_layer, IP, Ether, TCP
)
# Ether, TCP, hexdump, raw, rdpcap, load_contrib, conf, load_layer, 
# CANSocket, CAN, wrpcap, CCP, CRO, CONNECT, GET_SEED, UNLOCK, GET_DAQ_SIZE

# %% ../nbs/02.ccp.ipynb 9
load_layer("can")  # CAN
conf.contribs['CANSocket'] = {'use-python-can': False}
load_contrib("cansocket") # CANSocket
load_contrib("automotive.ccp")  # CCP, CRO, CONNECT, DISCONNECT, GET_SEED, UNLOCK, GET_DAQ_SIZE

# %% ../nbs/02.ccp.ipynb 10
pp = PrettyPrinter(indent=4, width=80, compact=True)

# %% ../nbs/02.ccp.ipynb 11
repo = git.Repo("./", search_parent_directories=True)  # get the Repo object of tspace
if os.path.basename(repo.working_dir) != "candycan":  # I'm in the parent repo!
    repo = repo.submodule("candycan").module()
pprint(repo.working_dir)

# %% ../nbs/02.ccp.ipynb 12
def get_argparser() -> argparse.ArgumentParser:
	"""Summary
	Get argument parser for command line arguments

	Returns:
		argparse.ArgumentParser: _description_
	"""
	parser = argparse.ArgumentParser(description='XCP Processing')

	parser.add_argument(
		'--protocol',
		type=str,
		choices=['ccp', 'xcp'],
		default='ccp',
		help='Protocol to use: ccp/xcp',
	)

	parser.add_argument(
		'--download',
		default=False,
		help='Download or upload: default is download(host->target)',
		action='store_true',
	)

	parser.add_argument(
		'--diff_flashing',
		default=True,
		help='use differential flashing',
		action='store_false',
	)

	parser.add_argument(
		'--a2l', 
		type=str,
        default=repo.working_dir+'/res/VBU_AI.json',
		help='a2l json file path')
		
	parser.add_argument(
		"--node-path",
		type=str,
		default=r"/PROJECT/MODULE[]",
		help="node path to search for calibration parameters",
	)

	parser.add_argument(
		"--leaves",
		type=list_of_strings,
		default=r"TQD_trqTrqSetNormal_MAP_v, " 
				r"VBU_L045A_CWP_05_09T_AImode_CM_single, " 
				r"Lookup2D_FLOAT32_IEEE, " 
				r"Lookup2D_X_FLOAT32_IEEE, " 
				r"Scalar_FLOAT32_IEEE, " 
				r"TQD_vVehSpd, "
				r"TQD_vSgndSpd_MAP_y, "
				r"TQD_pctAccPedPosFlt, "
				r"TQD_pctAccPdl_MAP_x",
			help="leaf nodes to search for",
	)

	parser.add_argument(
		'--channel', 
		type=int,
		default=3,
		help='CAN channel for flashing')
		
	parser.add_argument(
		'--download_id', 
		type=int,
		default=630,
		help='CAN message ID for downloading')
		
	parser.add_argument(
		'--upload_id', 
		type=int,
		default=631,
		help='CAN message ID for downloading')
		
	parser.add_argument(
		'--input', 
		type=str,
        default=repo.working_dir+'/res/download.json',
		help='Input file path')
	
	parser.add_argument(
		'--output', 
		type=str, 
        default=repo.working_dir+'/res/output.json',
		help='Output file path')
	return parser

# %% ../nbs/02.ccp.ipynb 27
def npa_to_packed_buffer(a: np.ndarray) -> str:
    """ convert a numpy array to a packed string buffer for flashing
    TODO: implementation as numpy ufunc

    Args:
        a (np.ndarray): input numpy array for flashing

    Returns:
        str: packed string buffer for flashing
    """
    b = [struct.pack("<f", x).hex() for x in np.nditer(a)]
    return ''.join(b)

# %% ../nbs/02.ccp.ipynb 30
def flash_xcp(xcp_calib: XCPCalib, data: pd.DataFrame, diff_flashing: bool=False, download: bool=True):
    """Summary
    Flash XCP data to target

    Args:
        xcp_calib (XCPCalib): XCP calibration as template, contains all the meta information except for data
        xcp_data (pd.DataFrame): input XCP data to be flashed, replace the value in xcp_calib
        diff_flashing (bool): Use differential flashing
        download (bool): Download or upload
    
    """
    
    # convert dataframe to a hex string to be flashed and assigned to XCPCalib field data
    xcp_calib.data = data.astype(np.float32).tobytes().hex()

    if download:
        if diff_flashing:
            raise NotImplementedError("Differential flashing not implemented yet")
        else:
            pass
        

    

# %% ../nbs/02.ccp.ipynb 70
CAN_TYPES = set(['NATIVE','PYTHON'])  # Navtive: Native CAN: PYTHON: Python CAN

def check_can_type(c: str) -> str:
    """Summary
    Check if the CAN type is valid

    Args:
        can_type (str): CAN type to be checked

    Returns:
        str: CAN type if valid

    Raises:
        ValueError: if CAN type is invalid
    """
    if c.upper() not in CAN_TYPES:
        raise ValueError(f"Invalid CAN type: {c}, valid types are: {CAN_TYPES}")
    return c

CANType = Annotated[str, AfterValidator(check_can_type)]

# %% ../nbs/02.ccp.ipynb 72
CAN_BUS_TYPES = set(['SOCKET', 'VIRTUAL', 'KVASER', 'PCAN', 'IXXAT', 'VECTOR', 'SERIAL', 'NEOVI'])

def check_can_bus_type(b: str) -> str:
    """Summary
    Check if the CAN bus type is valid

    Args:
        b (str): Python CAN bus type to be checked

    Returns:
        str: Python CAN bus type if valid

    Raises:
        ValueError: if CAN bus type is invalid
    """
    if b.upper() not in CAN_BUS_TYPES:
        raise ValueError(f"Invalid Python CAN bus type: {b}, valid types are: {CAN_BUS_TYPES}")
    return b

CANBusType = Annotated[str, AfterValidator(check_can_bus_type)]

# %% ../nbs/02.ccp.ipynb 75
def downlod_calib_data(xcp_calib: XCPCalib, 
                        can_type: CANType, 
                        channel: int,
                        bus_type: CANBusType, 
                        can_filter=list[dict],  
                        bit_rate: int=500_000, 
                        diff_flashing: bool=False):
    """Summary
    Download XCP calibration data to target

    Args:
        xcp_calib (XCPCalib): XCP calibration  to be downloaded into the target
        diff_flashing (bool): Use differential flashing
    """
    # init counter
    ctr = 0
    # create a socket
    match can_type:
        case 'NATIVE':
            load_layer("can")
            conf.contribs['CANSocket'] = {'use-python-can': False}
            load_contrib("cansocket")
            match bus_type:
                case 'SOCKET':
                    sock = CANSocket(channel='can'+str(channel), can_filter=can_filter, bit_rate = bit_rate, receive_own_messages=True)
                case 'VIRTUAL':
                    sock = CANSocket(channel='vcan'+str(channel), can_filter=can_filter, bit_rate = bit_rate, receive_own_messages=True)
                case _:
                    raise ValueError(f"Invalid CAN bus type: {bus_type}, valid types are: SOCKET or VIRTUAL for Native CANSOCKET")
        case 'PYTHON': 
            assert bus_type is not None, "Bus type must be specified for PYTHON CAN"
            load_layer("can")
            conf.contribs['CANSocket'] = {'use-python-can': True}
            load_contrib("cansocket")
            match bus_type:
                case 'SOCKET':
                    sock = CANSocket(bustype='socketcan', channel='can'+channel, can_filter=can_filter, bitrate=bit_rate, receive_own_messages=True)
                case 'VIRTUAL':
                    sock = CANSocket(bustype='socketcan', channel='vcan'+channel, can_filter=can_filter, bitrate=bit_rate, receive_own_messages=True)
                case 'KVASER':
                    sock = CANSocket(bustype='kvaser', channel=channel, can_filter=can_filter, bitrate=bit_rate, receive_own_messages=True)
                case 'VECTOR':
                    sock = CANSocket(bustype='vector', channel=channel, can_filter=can_filter, bitrate=bit_rate, receive_own_messages=True)
                case _:
                    raise ValueError(f"Invalid CAN bus type: {bus_type}, implemented valid types are: SOCKET, KVASER, VECTOR for Python-CAN CANSOCKET")

    # CONNECT
    ctr += 1
    cro = CCP(identifier=xcp_calib.config.download_can_id)/CRO(ctr=ctr)/CONNECT(station_address=0x00)
    dto = sock.sr1(cro)
    assert dto.return_code == 0x00

    for d in xcp_calib.data:
        # SET_MTA
        ctr += 1
        cro = CCP(identifier=xcp_calib.config.download_can_id)/CRO(ctr=ctr)/SET_MTA(address=int(d.address, 16))
        dto = sock.sr1(cro)
        assert dto.return_code == 0x00

        # Determine message tiling
        len_in_bytes = d.type_size * d.dim[0] * d.dim[1]
        assert len_in_bytes == len(d.value_bytes)
        tile_size = 6  # 6 bytes per tile as defined in CCP for DNLOAD_6
        tiles = len_in_bytes // tile_size 
        last_tile = len_in_bytes % tile_size
        # Download full size tiles with DNLOAD_6
        for i in range(tiles):
            ctr += 1
            cro = CCP(identifier=xcp_calib.config.download_can_id)/CRO(ctr=ctr)/DNLOAD_6(data=d.value_bytes[i*tile_size:(i+1)*tile_size])
            dto = sock.sr1(cro)
            assert dto.return_code == 0x00
        start_index = tiles * tile_size
        ctr += 1 
        cro = CCP(identifier=xcp_calib.config.download_can_id)/CRO(ctr=ctr)/DNLOAD(data=d.value_bytes[start_index:start_index+last_tile])
        dto = sock.sr1(cro)
        assert dto.return_code == 0x00

    # DISCONNECT
    ctr += 1
    cro = CCP(identifier=xcp_calib.config.download_can_id)/CRO(ctr=ctr)/DISCONNECT(station_address=0x00)
    dto = sock.sr1(cro)
    assert dto.return_code == 0x00

# %% ../nbs/02.ccp.ipynb 77
def upload_calib_data(xcp_calib: XCPCalib, diff_flashing: bool=False)->None:
    """Summary
    Upload XCP calibration data from target to host, the result will update the xcp_calib.data field

    Args:
        xcp_calib (XCPCalib): XCP calibration  to be uploaded from the target to host
        diff_flashing (bool): Use differential flashing
    """

    # init counter
    ctr = 0
    # create a socket
    sock = CANSocket(channel='can'+str(xcp_calib.config.channel), receive_own_messages=True)

    # CONNECT
    ctr += 1
    cro = CCP(identifier=xcp_calib.config.download_can_id)/CRO(ctr=ctr)/CONNECT(station_address=0x00)
    dto = sock.sr1(cro)
    assert dto.return_code == 0x00

    for d in xcp_calib.data:
        # SET_MTA
        ctr += 1
        cro = CCP(identifier=xcp_calib.config.download_can_id)/CRO(ctr=ctr)/SET_MTA(address=int(d.address, 16))
        dto = sock.sr1(cro)
        assert dto.return_code == 0x00

        # Determine message tiling
        len_in_bytes = d.type_size * d.dim[0] * d.dim[1]
        # assert len_in_bytes == len(d.value_bytes)
        tile_size = 5
        tiles = len_in_bytes // tile_size 
        last_tile = len_in_bytes % tile_size
        
        # Upload tiles with tile_size (maximal 5 as defined by CCP） bytes with UPLOAD
        ba_uploaded = bytearray()
        for i in range(tiles):
            ctr += 1
            cro = CCP(identifier=xcp_calib.config.download_can_id)/CRO(ctr=ctr)/UPLOAD(size=tile_size)
            upload_dto = sock.sr1(cro)
            assert upload_dto.return_code == 0x00
            ba_uploaded += upload_dto.data
            

        start_index = tiles * tile_size
        ctr += 1 
        cro = CCP(identifier=xcp_calib.config.download_can_id)/CRO(ctr=ctr)/UPLOAD(last_tile)
        upload_dto = sock.sr1(cro)
        assert upload_dto.return_code == 0x00
        ba_uploaded += upload_dto.data

        d.value = ba_uploaded.hex()

    # DISCONNECT
    ctr += 1
    cro = CCP(identifier=xcp_calib.config.download_can_id)/CRO(ctr=ctr)/DISCONNECT(station_address=0x00)
    dto = sock.sr1(cro)
    assert dto.return_code == 0x00

# %% ../nbs/02.ccp.ipynb 78
@contextlib.contextmanager
def scapy_cpp_can_connect(can_type: CANType='VIRTUAL', channel: int=0):
    """Summary
    Context manager for scapy CAN socket

    Args:
        channel (str): CAN channel to use, default is vcan0

    Yields:
        CANSocket: CAN socket object
    """
    sock = CANSocket(channel=channel)
    yield sock
    sock.close()

# %% ../nbs/02.ccp.ipynb 83
if __name__ == "__main__" and "__file__" in globals():  # only run if this file is called directly

    protocol = inquirer.select(
        message="What's the protocol?",
        choices=[
            Choice(value="ccp", name="CCP"),
            Choice(value="xcp", name="XCP"),
        ],
        default="ccp",
    ).execute()

    download = inquirer.confirm(
        message="Downloading(host->target)?",
        confirm_letter="y",
        reject_letter="n",
        default=True,
    ).execute()

    differential_flashing = inquirer.confirm(
        message="Differential Flashing?",
        confirm_letter="y",
        reject_letter="n",
        default=False,
    ).execute()

    a2l_file_path = inquirer.text(
        message="a2l file path",
        validate=EmptyInputValidator(),
        default='/res/vbu_ai.json'
    ).execute()

    # node_path = inquirer.text(
    #     message="node path",
    #     validate=EmptyInputValidator(),
    # 	default=r"/PROJECT/MODULE[]",
    # ).execute()

    # leaves = inquirer.text(
    #     message="leaves",
    #     validate=EmptyInputValidator(),
    # 	default=r"TQD_trqTrqSetNormal_MAP_v, VBU_L045A_CWP_05_09T_AImode_CM_single, Lookup2D_FLOAT32_IEEE, Lookup2D_X_FLOAT32_IEEE, Scalar_FLOAT32_IEEE, TQD_vVehSpd, TQD_vSgndSpd_MAP_y, TQD_pctAccPedPosFlt, TQD_pctAccPdl_MAP_x"
    # ).execute()

    can_channel = inquirer.number(
        message="CAN channel for flashing",
        min_allowed=0,
        max_allowed=32,
        validate=EmptyInputValidator(),
        default=3,
    ).execute()

    download_id = inquirer.number(
        message="CAN ID for downloading",
        min_allowed=0,
        max_allowed=9999,
        validate=EmptyInputValidator(),
        default=630,
    ).execute()

    upload_id = inquirer.number(
        message="CAN ID for uploading",
        min_allowed=0,
        max_allowed=9999,
        validate=EmptyInputValidator(),
        default=631,
    ).execute()

    input_file_path = inquirer.text(
        message="Input file path",
        validate=EmptyInputValidator(),
        default="/res/download.json",
    ).execute()

    output_file_path = inquirer.text(
        message="Output file path",
        validate=EmptyInputValidator(),
        default="/res/output.json",
    ).execute()

    args = get_argparser().parse_args()
    args.protocol = protocol
    args.download = download
    args.diff_flashing = differential_flashing
    # args.a2l = a2l_file_path
    # args.node_path = node_path
    # args.leaves = leaves
    args.channel = can_channel
    args.download_id = download_id
    args.upload_id = upload_id
    args.input = repo.working_dir+input_file_path
    args.output = repo.working_dir+output_file_path
    pprint(args)

    xcp_calib_from_xcpjson = Get_XCPCalib_From_XCPJSon(args.input)
    xcp_data = Generate_Init_XCPData_From_A2L(
        a2l=args.a2l, keys=args.leaves, node_path=args.node_path
    )
    try:
        XCPData.model_validate(xcp_data)
    except ValidationError as exc:
        print(exc)

    xcp_data.value = xcp_calib_from_xcpjson.data[0].value
    pprint(xcp_data)

    xcp_calib = XCPCalib(
        config=XCPConfig(
            channel=args.channel, download=args.download_id, upload=args.upload_id
        ),
        data=[xcp_data],
    )
    pprint(xcp_calib)
